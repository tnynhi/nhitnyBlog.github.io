{"pageProps":{"data":{"Id":1006,"Title":"Javascript Concepts - Part1","Author":"Soumyajit","Tags":"Javascript Interview","Topic":"Javascript","Abstract":"Learning some of the fundamental concepts of Javascript and questions asked in javascript interview.","HeaderImage":"/BL-1006/header.png","isPublished":true},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\",\n    h3: \"h3\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      id: \"New-Features-in-ES6\",\n      children: \"New Features in ES6\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Some of the new features of javascript introductes in ES6 are:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"The Let keyword\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"The Const keyword\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Arrow Functions\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Promises\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Map Object\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"// Create a new Map\\nconst fruits = new Map();\\n\\n// Add new Elements to the Map\\nfruits.set(apples, 500);\\nfruits.set(bananas, 300);\\nfruits.set(oranges, 200);\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Set Object\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"// Create a Set\\nconst letters = new Set();\\n\\n// Add some values to the Set\\nletters.add(\\\"a\\\");\\nletters.add(\\\"b\\\");\\nletters.add(\\\"c\\\");\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Classes\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"class ClassName {\\n  constructor() { ... }\\n}\\n\\n// Example\\nclass Car {\\n  constructor(name, year) {\\n    this.name = name;\\n    this.year = year;\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"Difference-between-Let-and-Var-and-Const\",\n      children: \"Difference between Let and Var and Const\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"Comparision-of-Declarations\",\n      children: \"Comparision of Declarations\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"One of the biggest problems with declaring variables with the var keyword is that you can easily overwrite variable declarations:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"var camper = \\\"James\\\";\\nvar camper = \\\"David\\\";\\nconsole.log(camper);\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In the code above, the camper variable is originally declared as James, and is then overridden to be David. The console then displays the string David.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If you replace var with let in the code above, it results in an error:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"let camper = \\\"James\\\";\\nlet camper = \\\"David\\\";\\nThe error can be seen in your browser console.(Uncaught SyntaxError: Identifier 'camper' has already been declared)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"So unlike var, when you use let, a variable with the same name can only be declared once.\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"Comparision-of-scopes-of-the-var-and-let-Keywords\",\n      children: \"Comparision of scopes of the var and let Keywords\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"When you declare a variable with the var keyword, it is declared globally.\\nThe let keyword behaves similarly, but with some extra features. When you declare a variable with the let keyword inside a block, statement, or expression, its scope is limited to that block, statement, or expression.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"var numArray = [];\\nfor (var i = 0; i < 3; i++) {\\n  numArray.push(i);\\n}\\nconsole.log(numArray);\\nconsole.log(i);\\nHere the console will display the values [0, 1, 2] and 3.\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"With the var keyword, i is declared globally. So when i++ is executed, it updates the global variable.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This behavior will cause problems if you were to create a function and store it for later use inside a for loop that uses the i variable. This is because the stored function will always refer to the value of the updated global i variable.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"var printNumTwo;\\nfor (var i = 0; i < 3; i++) {\\n  if (i === 2) {\\n    printNumTwo = function() {\\n      return i;\\n    };\\n  }\\n}\\nconsole.log(printNumTwo());\\nHere the console will display the value 3.\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As you can see, printNumTwo() prints 3 and not 2. This is because the value assigned to i was updated and the printNumTwo() returns the global i and not the value i had when the function was created in the for loop.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The let keyword does not follow this behavior:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"let printNumTwo;\\nfor (let i = 0; i < 3; i++) {\\n    if (i === 2) {\\n        printNumTwo = function() {\\n            return i;\\n        };\\n    }\\n}\\nconsole.log(printNumTwo());\\nconsole.log(i);\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here the console will display the value 2, and an error that i is not defined. i is not defined because it was not declared in the global scope. It is only declared within the for loop statement. printNumTwo() returned the correct value because three different i variables with unique values (0, 1, and 2) were created by the let keyword within the loop statement.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"Const\",\n      children: \"Const\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"While var and let can be declared without being initialized, const must be initialized during declaration.\\n\", _jsx(_components.code, {\n        children: \"Const cannot be initialized after declaritions\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"However, it is important to understand that objects (including arrays and functions) assigned to a variable using const are still mutable. Using the \", _jsx(_components.code, {\n        children: \"const declaration only prevents reassignment of the variable identifier.\"\n      })]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"const s = [5, 6, 7];\\ns = [1, 2, 3];\\ns[2] = 45;\\nconsole.log(s);\\nThe console.log will display the value [5, 6, 45].\\n\\ns = [1, 2, 3] will result in an error.\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As you can see, you can mutate the object [5, 6, 7] itself and the variable s will still point to the altered array [5, 6, 45]. Like all arrays, the array elements in s are mutable, but because const was used, you cannot use the variable identifier s to point to a different array using the assignment operator.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"Variable-shadowing\",\n      children: \"Variable shadowing\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"let number = 10;\\n\\nfunction displayDouble() {\\n  //new variable is defined with the same name as variable on line 1 - outer scope\\n  let number = 3;\\n\\n  number *= 2;\\n  console.log(number); //=> 6\\n}\\n\\ndisplayDouble();\\nconsole.log(number); //=> 10\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In this case, both variables on line 1 and 5 are defined with the same name — number.This has a significant result: the variable defined in the outer scope is ‘shadowed’ by the variable defined in the inner scope.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"String-in-Javascript\",\n      children: \"String in Javascript\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In JavaScript, String values are immutable, which means that they cannot be altered once created.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For example, the following code:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"let myStr = \\\"Bob\\\";\\nmyStr[0] = \\\"J\\\";\\ncannot change the value of myStr to Job, because the contents of myStr cannot be altered.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"Escape-Sequences-in-Strings\",\n      children: \"Escape Sequences in Strings\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"Code   Output\\n\\\\' single quote\\n\\\\\\\" double quote\\n\\\\\\\\ backslash\\n\\\\n newline\\n\\\\r carriage return\\n\\\\t tab\\n\\\\b word boundary\\n\\\\f form feed\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"Difference-between-==-and-===-in-javascript\",\n      children: \"Difference between '==' and '===' in javascript\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Strict equality (===) is the counterpart to the equality operator (==). However, unlike the equality operator, which attempts to convert both values being compared to a common type, the strict equality operator does not perform a type conversion.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If the values being compared have different types, they are considered unequal, and the strict equality operator will return false.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"Examples 1:\\n\\n3 === 3 //true\\n3 === '3' // false\\n1 == [1] //true\\n1 === [1] //false\\nnull == undefined //true\\n\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"Example 2:‌\\nconst number = 1234\\nconst stringNumber = '1234'\\n\\nconsole.log(number == stringNumber) //true\\nconsole.log(number === stringNumber)  //false\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The value of number and stringNumber looks similar here. However, the type of number is Number and type of stringNumber is string. Even though the values are same, the type is not the same. Hence a == check returns true, but when checked for value and type, the value is false.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"Example 3:\\nconsole.log(0 == false) //true\\nconsole.log(0 === false) //false\\nReason: same value, different type. Type coercion\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This is an interesting case. The value of 0 when checked with false is same. It is so because 0 and false have the same value for JavaScript, but when checked for type and value, the value is false because 0 is a number and false is boolean.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"Example 4:\\nconst str = \\\"\\\"\\n\\nconsole.log(str == false) //true\\nconsole.log(str === false) //false\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The value of empty string and false is same in JavaScript. Hence, == returns true. However, the type is different and hence === returns false.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"Example 5:\\nlet obj1 = { a: 1, b: 2 };\\nlet obj2 = { a: 1, b: 2 };\\nconsole.log(obj1 == obj2); //false\\nconsole.log(obj1 === obj2); //false\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The important thing to understand here is that the variables, obj1 and obj2 (which could be an Object, Array or Function) each contain only a reference to a location in memory. Not the value of the object.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"Explain-how-this-works-in-JavaScript\",\n      children: \"Explain how this works in JavaScript\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To access a property of an object from within a method of the same object, you need to use the this keyword.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"const person = {\\n    name: 'John',\\n    age: 30,\\n\\n    // accessing name property by using this.name\\n    greet: function() { console.log('The name is' + ' ' + this.name); }\\n};\\n\\nperson.greet();\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In the above example, a person object is created. It contains properties (name and age) and a method greet.\\nIn the method greet, while accessing a property of an object, this keyword is used.\\nIn order to access the properties of an object, this keyword is used following by . and key.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This keyword refers to the \", _jsx(_components.code, {\n        children: \"object where it is called.\"\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"1-this-Inside-Global-Scope\",\n      children: \"1 this Inside Global Scope\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"When this is used alone, this refers to the global object (window object in browsers). For example,\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"let a = this;\\nconsole.log(a);  // Window {}\\n\\nthis.name = 'Sarah';\\nconsole.log(window.name); // Sarah\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"2-this-Inside-Function\",\n      children: \"2 this Inside Function\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"When this is used in a function, this refers to the global object (window object in browsers). For example,\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"function greet() {\\n    // this inside function\\n    // this refers to the global object\\n    console.log(this);\\n}\\ngreet(); // Window {}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"3-this-Inside-Constructor-Function\",\n      children: \"3 this Inside Constructor Function\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In JavaScript, constructor functions are used to create objects. When a function is used as a constructor function, this refers to the object inside which it is used. For example,\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"function Person() {\\n    this.name = 'Jack';\\n    console.log(this);\\n}\\n\\nlet person1 = new Person();\\nconsole.log(person1.name);\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here, this refers to the person1 object. That's why, person1.name gives us Jack.\\nWhen this is used with ES6 classes, it refers to the object inside which it is used.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For example,\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"// creating a class\\nclass Person {\\n  constructor(name) {\\n    this.name = name;\\n  }\\n}\\nThe class keyword is used to create a class. The properties are assigned in a constructor function.\\n\\n// creating a class\\nclass Person {\\n  constructor(name) {\\n    this.name = name;\\n  }\\n}\\n\\n// creating an object\\nconst person1 = new Person('John');\\nconst person2 = new Person('Jack');\\n\\nconsole.log(person1.name); // John\\nconsole.log(person2.name); // Jack\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"4-this-Inside-Object-Method\",\n      children: \"4 this Inside Object Method\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"When this is used inside an object's method, this refers to the object it lies within. For example,\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"const person = {\\nname : 'Jack',\\nage: 25,\\n    // this inside method\\n    // this refers to the object itself\\n    greet() {\\n        console.log(this);\\n        console.log(this.name);\\n    }\\n\\n}\\n\\nperson.greet();\\nOutput\\n{name: \\\"Jack\\\", age: 25, greet: ƒ}\\nJack\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"5-this-Inside-Inner-Function\",\n      children: \"5 this Inside Inner Function\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"When you access this inside an inner function (inside a method), this refers to the global object. For example,\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"const person = {\\nname : 'Jack',\\nage: 25,\\n\\n    // this inside method\\n    // this refers to the object itself\\n    greet() {\\n        console.log(this);        // {name: \\\"Jack\\\", age ...}\\n        console.log(this.age);  // 25\\n\\n        // inner function\\n        function innerFunc() {\\n            // this refers to the global object\\n            console.log(this);       // Window { ... }\\n            console.log(this.age);    // undefined\\n        }\\n        innerFunc();\\n    }\\n}\\nperson.greet();\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"6-this-Inside-Arrow-Function\",\n      children: \"6 this Inside Arrow Function\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Inside the arrow function, this refers to the parent scope. For example,\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"const greet = () => {\\n    console.log(this);\\n}\\ngreet(); // Window {...}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"Arrow functions do not have their own this\"\n      }), \". When you use this inside an arrow function, this refers to its parent scope object.\\nFor example,\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"const greet = {\\n    name: 'Jack',\\n\\n    // method\\n    sayHi () {\\n        let hi = () => console.log(this.name);\\n        hi();\\n    }\\n}\\ngreet.sayHi(); // Jack\\n\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"const person = {\\n    name : 'Jack',\\n    age: 25,\\n\\n    // this inside method\\n    // this refers to the object itself\\n    greet() {\\n        console.log(this);\\n        console.log(this.age);\\n\\n        // inner function\\n        let innerFunc = () => {\\n\\n            // this refers to the global object\\n            console.log(this);\\n            console.log(this.age);\\n        }\\n        innerFunc();\\n    }\\n}\\n\\nperson.greet();\\n\\nOutput:\\n{name: \\\"Jack\\\", age: 25, greet: ƒ}\\n25\\n{name: \\\"Jack\\\", age: 25, greet: ƒ}\\n25\\nHere, innerFunc() is defined using the arrow function. It takes this from its parent scope. Hence, this.age gives 25.\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"7-this-Inside-Function-with-Strict-Mode\",\n      children: \"7 this Inside Function with Strict Mode\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"When this is used in a function with strict mode, this is undefined. For example,\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"'use strict';\\nthis.name = 'Jack';\\nfunction greet() {\\n\\n    // this refers to undefined\\n    console.log(this);\\n}\\ngreet(); // undefined\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"How-is-arrow-functions-different-from-normal-functions-in-javascript\",\n      children: \"How is arrow functions different from normal functions in javascript\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"this-Keyword\",\n      children: \"this Keyword\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Inside a \", _jsx(_components.code, {\n        children: \"regular function, this keyword refers to the function\"\n      }), \" where it is called.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"However, \", _jsx(_components.code, {\n        children: \"this is not associated with arrow functions\"\n      }), \". \", _jsx(_components.code, {\n        children: \"Arrow function does not have its own this\"\n      }), \". So whenever you call this, it refers to its parent scope.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Inside a regular function\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"function Person() {\\n    this.name = 'Jack',\\n    this.age = 25,\\n    this.sayName = function () {\\n\\n        // this is accessible\\n        console.log(this.age);\\n\\n        function innerFunc() {\\n            // this refers to the global object\\n            console.log(this.age);\\n            console.log(this);\\n        }\\n        innerFunc();\\n    }\\n}\\n\\nlet x = new Person();\\nx.sayName();\\n\\nOutput:\\n25\\nundefined\\nWindow {}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here, this.age inside this.sayName() is accessible because this.sayName() is the method of an object.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"However, innerFunc() is a normal function and this.age is not accessible because this refers to the global object (Window object in the browser). Hence, this.age inside the innerFunc() function gives undefined.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Inside an arrow function\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"function Person() {\\n    this.name = 'Jack',\\n    this.age = 25,\\n    this.sayName = function () {\\n\\n        console.log(this.age);\\n        let innerFunc = () => {\\n            console.log(this.age);\\n        }\\n        innerFunc();\\n    }\\n}\\n\\nconst x = new Person();\\nx.sayName();\\n\\nOutput\\n25\\n25\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here, the innerFunc() function is defined using the arrow function. And inside the arrow function, this refers to the parent's scope. Hence, this.age gives 25.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"Arguments-Binding\",\n      children: \"Arguments Binding\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"Regular functions have arguments binding\"\n      }), \". That's why when you pass arguments to a regular function, you can access them using the arguments keyword.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"let x = function () {\\n    console.log(arguments);\\n}\\nx(4,6,7); // Arguments [4, 6, 7]\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"Arrow functions do not have arguments binding\"\n      }), \".\\nWhen you try to access an argument using the arrow function, it will give an error. For example,\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"let x = () => {\\n    console.log(arguments);\\n}\\nx(4,6,7);\\n// ReferenceError: Can't find variable: arguments\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To solve this issue, you can use the spread syntax.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"let x = (...n) => {\\n  console.log(n);\\n}\\nx(4,6,7); // [4, 6, 7]\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"Id":1006,"Title":"Javascript Concepts - Part1","Author":"Soumyajit","Tags":"Javascript Interview","Topic":"Javascript","Abstract":"Learning some of the fundamental concepts of Javascript and questions asked in javascript interview.","HeaderImage":"/BL-1006/header.png","isPublished":true}},"id":"javascript-concepts---part1","headings":[{"text":"New Features in ES6","level":2,"id":"New-Features-in-ES6","uid":1001},{"text":"Difference between Let and Var and Const","level":2,"id":"Difference-between-Let-and-Var-and-Const","uid":1002},{"text":"Comparision of Declarations","level":3,"id":"Comparision-of-Declarations","uid":1003},{"text":"Comparision of scopes of the var and let Keywords","level":3,"id":"Comparision-of-scopes-of-the-var-and-let-Keywords","uid":1004},{"text":"Const","level":3,"id":"Const","uid":1005},{"text":"Variable shadowing","level":2,"id":"Variable-shadowing","uid":1006},{"text":"String in Javascript","level":2,"id":"String-in-Javascript","uid":1007},{"text":"Escape Sequences in Strings","level":2,"id":"Escape-Sequences-in-Strings","uid":1008},{"text":"Difference between '==' and '===' in javascript","level":2,"id":"Difference-between-==-and-===-in-javascript","uid":1009},{"text":"Explain how this works in JavaScript","level":2,"id":"Explain-how-this-works-in-JavaScript","uid":1010},{"text":"1 this Inside Global Scope","level":3,"id":"1-this-Inside-Global-Scope","uid":1011},{"text":"2 this Inside Function","level":3,"id":"2-this-Inside-Function","uid":1012},{"text":"3 this Inside Constructor Function","level":3,"id":"3-this-Inside-Constructor-Function","uid":1013},{"text":"4 this Inside Object Method","level":3,"id":"4-this-Inside-Object-Method","uid":1014},{"text":"5 this Inside Inner Function","level":3,"id":"5-this-Inside-Inner-Function","uid":1015},{"text":"6 this Inside Arrow Function","level":3,"id":"6-this-Inside-Arrow-Function","uid":1016},{"text":"7 this Inside Function with Strict Mode","level":3,"id":"7-this-Inside-Function-with-Strict-Mode","uid":1017},{"text":"How is arrow functions different from normal functions in javascript","level":2,"id":"How-is-arrow-functions-different-from-normal-functions-in-javascript","uid":1018},{"text":"this Keyword","level":3,"id":"this-Keyword","uid":1019},{"text":"Arguments Binding","level":3,"id":"Arguments-Binding","uid":1020}],"topics":["Git","React","Javascript"]},"__N_SSG":true}