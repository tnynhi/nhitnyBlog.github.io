{"pageProps":{"blogs":[{"data":{"Id":1001,"Title":"Understanding Git and Github","Author":"Soumyajit","Tags":"Git Github","Topic":"Git","Abstract":"Understanding the  difference between Git and Github with examples and their main use cases or how they are helpful for the developers.","HeaderImage":"/BL-1001/header.jpg","isPublished":true},"content":"\r\n## What is git? {#What-is-git}\r\n\r\nGit is a version control system which is maintained on your local system. Git gives us a record for ongoing programming versions. It can be used completely exclusive of any cloud-hosting service i.e. we don’t even need internet to access git.\r\n\r\n## Version Control System {#Version-Control-System}\r\n\r\n![What is VCS](/BL-1001/vcs.png)\r\n\r\nIt is a program to keep track of the changes in projects, by tracking or logging the files changes over time. A version control system allows us to review, restore earlier versions and even branching and merging or code.\r\n\r\n## What Is GitHub? {#What-Is-GitHub}\r\n\r\nGitHub is a cloud-based hosting service that lets us manage Git repositories. It’s an online database that allows you to keep track of and share your Git version control projects outside of your local computer.\r\nOther Git repository hosting services also exist: Eg:- GitLab, BitBucket, and SourceForge\r\n\r\nGitHub just takes things a little bit further than Git, offering more functionality and resources, as well as a place online to store and collaborate on projects. And because GitHub is cloud-based, an individual’s Git repositories can be remotely accessed by any authorized person, from any computer, anywhere in the world.\r\n\r\nThrough GitHub, one can share code with others, giving them the power to make revisions or edits on your various Git branches. This makes it possible for entire teams to coordinate together on single projects in real-time. As changes are introduced, new branches are created, allowing the team to continue to revise the code without overwriting each other's work.\r\n\r\n## Conclusion {#Conclusion}\r\n\r\n![Diffrence between git and github](/BL-1001/gitVsGithub.webp)\r\n\r\n## Why Use a Version Control System? {#Why-Use-a-Version-Control-System}\r\n\r\n- Collaboration\r\n- Storing Versions\r\n- Restoring Previous Versions\r\n","readTime":{"text":"2 min read","minutes":1.4,"time":84000,"words":280}},{"data":{"Id":1002,"Title":"Client Vs Server Side Rendering","Author":"Soumyajit","Tags":"React Next","Topic":"React","Abstract":"Difference between different types of rendering techniques and advantage of Next.js over React.js.","HeaderImage":"/BL-1002/next-react.jpg","isPublished":true},"content":"\r\n## Client Side Rendering {#Client-Side-Rendering}\r\n\r\n![Client Side Rendering](/BL-1002/csr.png)\r\n\r\nWhen we talk about client-side rendering,it’s about rendering content in the browser using JavaScript.\r\n\r\nSo instead of getting all the content from the HTML document itself, a simple HTML document with a JavaScript file in initial loading itself is received, which renders the rest of the site using the browser.\r\n\r\nWith client-side rendering, the initial page load is naturally a bit slow. However, after that, every subsequent page load is very fast. In this approach, communication with server happens only for getting the run-time data. Moreover, there is no need to reload the entire UI after every call to the server. The client-side framework manages to update UI with changed data by re-rendering only that particular DOM element.\r\n\r\n## Server Side Rendering {#Server-Side-Rendering}\r\n\r\n![Server Side Rendering](/BL-1002/ssr.png)\r\n\r\nIn server-side rendering when a user makes a request to a webpage, the server prepares an HTML page by fetching user-specific data and sends it to the user’s machine over the internet. Webpages are generated on your server for every request. This entire process of fetching data from the database, creating an HTML page and serve it to user is known as SSR.\r\n\r\n## Static Site Generation {#Static-Site-Generation}\r\n\r\nAt build time, your app will fetch all the data required and compile it down to static webpages. After a production build is created, every request is going to reuse that statically generated HTML file. This provides the best performance and can easily be cached on a CDN.\r\n\r\n## Problems with React.js {#Problems-with-React.js}\r\n\r\nReact uses Client Side Rendering. With React, nothing gets displayed until all of your JavaScript loads. Your HTML is nearly empty and React injects your content in your HTML with JavaScript.\r\nThis leads multiple problems:-\r\n\r\n- When the browser is loading the JavaScript, the screen is blank because `<div id=\"root\"></div>` does not show anything. Depending on the size of your JavaScript bundle, this could lead to your visitors staring at a white screen for a couple of seconds.\r\n\r\n- Most SEO crawlers do not have JavaScript enabled. DuckDuckGo, Google, Bing and any other search engine would not actually know what is on your website since it requires JavaScript to display the content. You will not be ranked at all on Search Engines.\r\n\r\n## Methods for Prerendering using Next.js {#Methods-for-Prerendering-using-Next.js}\r\n\r\nNext.js offers `(Server Side Rendering)SSR` and `(Static Site Generation)SSG` using `getStaticProps` and `getServerSideProps`.\r\n\r\n### getStaticProps {#getStaticProps}\r\n\r\ngetStaticProps is a server-side function that will only be called at build time. The build will then use the response from getStaticProps to generate a static webpage.\r\n\r\nSince stale data is a problem with static generated pages, there is an option you can set to revalidate your static page and rebuild it if data changes. revalidate: 60 will check your data every 60 seconds and rebuild the page if needed.\r\n\r\nExample Use:\r\n\r\n```\r\n// This function gets called at build time on server-side.\r\nexport async function getStaticProps() {\r\nconst res = await fetch('https://.../data');\r\nconst data = await res.json();\r\n\r\n// By returning { props: data }, the Dashboard component\r\n// will receive `data` as a prop at build time\r\nreturn {\r\nprops: {\r\ndata\r\n},\r\n// Check if data changes every 60 seconds.\r\n// Rebuild page if different\r\nrevalidate: 60\r\n};\r\n}\r\n\r\n// data will be populated at build time by getStaticProps()\r\nexport default function Dashboard({ data }) {\r\nreturn <div>{data}</div>;\r\n}\r\n```\r\n\r\n### getServerSideProps {#getServerSideProps}\r\n\r\ngetServerSideProps is similar to getStaticProps but is called every time the page loads instead of at build time. This ensures that all of your initial data is up to date on every load.\r\n\r\nSince this is called on every load, you do not need to revalidate like getStaticProps. This also leads to a slower load time since you are no longer serving a static file, but have to rebuild on every load.\r\n\r\nExample Use:\r\n\r\n```\r\n// This function gets called at build time on server-side.\r\nexport async function getServerSideProps() {\r\nconst res = await fetch('https://.../data');\r\nconst data = await res.json();\r\n\r\n// By returning { props: data }, the Dashboard component\r\n// will receive `data` as a prop at build time\r\nreturn {\r\nprops: {\r\ndata\r\n}\r\n};\r\n}\r\n\r\n// data will be populated at build time by getServerSideProps()\r\nexport default function Dashboard({ data }) {\r\nreturn <div>{data}</div>;\r\n}\r\n```\r\n\r\n## Benefits of using Next.js {#Benefits-of-using-Next.js}\r\n\r\n- Search engines can crawl the site for better SEO.\r\n- The initial page load is faster.\r\n  ![nextjs pros and cons](/BL-1002/nextjs-pros-and-cons.png)\r\n\r\n**References:**\r\n\r\n- <a href=\"https://nextjs.org/docs/getting-started\" target=\"_blank\">Next.js</a>\r\n","readTime":{"text":"4 min read","minutes":3.73,"time":223800,"words":746}},{"data":{"Id":1003,"Title":"Core Concept You Need to Know About React","Author":"Soumyajit","Tags":"React Interview","Topic":"React","Abstract":"Learning some of the fundamental concepts of React.js and top questions asked in react interview.","HeaderImage":"/BL-1003/reactjs.png","isPublished":true},"content":"\r\n## Why use react.js {#Why-use-react.js}\r\n\r\n**_1.Reusable Components:_**\r\n\r\nReact provides a component based structure.Each tiny elements like button, checkbox, dropdown etc can be a component and the we create wrapper components composed of those smaller components.Each component decides how it should be rendered. Each component has its own internal logic.\r\n\r\n**_2.Fast render with Virtual DOM_**\r\n\r\nReact uses virtual DOM to render the view.virtual DOM is a virtual representation of the real DOM. Each time the data changes in a react app, a new virtual DOM gets created. Creating a virtual DOM is much faster than rendering the UI inside the browser. Therefore, with the use of virtual DOM, the efficiency of the app improves.\r\n\r\n**_3.SEO friendly_**\r\n\r\nReact allows developers to develop user interfaces that can be easily navigated in various search engines. It also allows server-side rendering, which boosts the SEO of an app.\r\n\r\n## What is JSX? {#What-is-JSX}\r\n\r\nJSX stands for JavaScript XML.\r\nIt allows us to write HTML inside JavaScript and place them in the DOM without using functions like `appendChild( )` or `createElement( )`.\r\n\r\n- Without using JSX, we would have to create an element by the following process:\r\n\r\n```\r\nconst text = React.createElement('p', {}, 'This is a text');\r\nconst container = React.createElement('div','{}',text );\r\nReactDOM.render(container,document.getElementById('app'));\r\n```\r\n\r\n- Using JSX, the above code can be simplified:\r\n\r\n````\r\nconst container = (\r\n\r\n <div>\r\n   <p>This is a text</p>\r\n </div>\r\n);\r\nReactDOM.render(container,document.getElementById('app'));```\r\n````\r\n\r\nAs one can see in the code above, we are directly using HTML inside JavaScript\\*\r\n\r\n## What is the virtual DOM? How does react use the virtual DOM to render the UI? {#What-is-the-virtual-DOM-How-does-react-use-the-virtual-DOM-to-render-the-UI}\r\n\r\n_DOM stands for 'Document Object Model'. In simple terms, it is a structured representation of the HTML elements that are present in a webpage or web-app. DOM represents the entire UI of your application_\r\n\r\nVirtual DOM is a concept where a virtual representation of the real DOM is kept inside the memory and is synced with the real DOM by a library such as ReactDOM.\r\n\r\n![Virtual Dom](/BL-1003/vdom.png)\r\n\r\n**Why was virtual DOM introduced?**\r\n\r\nDOM manipulation is an integral part of any web application, but DOM manipulation is quite slow when compared to other operations in JavaScript.\r\n\r\nThe efficiency of the application gets affected when several DOM manipulations are being done. Most JavaScript frameworks update the entire DOM even when a small part of the DOM changes.\r\n\r\nFor example, consider a list that is being rendered inside the DOM. If one of the items in the list changes, the entire list gets rendered again instead of just rendering the item that was changed/updated. This is called inefficient updating.\r\nTo address the problem of inefficient updating, the react team introduced the concept of virtual DOM.\r\n\r\n**How does it work?**\r\n\r\n![Virtual Dom](/BL-1003/real-virtual.png)\r\n\r\nFor every DOM object, there is a corresponding virtual DOM object(copy), which has the same properties.\r\n\r\nThe main difference between the real DOM object and the virtual DOM object is that any changes in the virtual DOM object will not reflect on the screen directly. Consider a virtual DOM object as a blueprint of the real DOM object.\r\nWhenever a JSX element gets rendered, every virtual DOM object gets updated.\r\n\r\nReact uses two virtual DOMs to render the user interface. One of them is used to store the current state of the objects and the other to store the previous state of the objects.\r\n\r\nWhenever the virtual DOM gets updated, react compares the two virtual DOMs and gets to know about which virtual DOM objects were updated.\r\n\r\nAfter knowing which objects were updated, react renders only those objects inside the real DOM instead of rendering the complete real DOM.This way, with the use of virtual DOM, react solves the problem of inefficient updating\r\n\r\n## Explain React state and props? {#Explain-React-state-and-props}\r\n\r\nA React component can access dynamic information in two ways: props and state.\r\n\r\n### React State {#React-State}\r\n\r\nEvery component in react has a built-in state object, which contains all the property values that belong to that component.\r\n\r\nIn other words, the state object controls the behaviour of a component. Any change in the property values of the state object leads to re-rendering of the component.\r\n\r\n_Note- State object is not available in functional components but, we can use React Hooks to add state to a functional component._\r\n\r\nHow to declare a state object?\r\n\r\n```\r\nExample:\r\nclass Car extends React.Component{\r\n constructor(props){\r\n   super(props);\r\n   this.state = {\r\n     brand: \"BMW\",\r\n     color: \"black\"\r\n   }\r\n }\r\n}\r\n```\r\n\r\nHow to use and update the state object?\r\n\r\n```\r\nclass Car extends React.Component {\r\n constructor(props) {\r\n   super(props);\r\n   this.state = {\r\n     brand: \"BMW\",\r\n     color: \"Black\"\r\n   };\r\n }\r\n\r\n changeColor() {\r\n   this.setState(prevState => {\r\n     return { color: \"Red\" };\r\n   });\r\n }\r\n\r\n render() {\r\n   return (\r\n     <div>\r\n       <button onClick={() => this.changeColor()}>Change Color</button>\r\n       <p>{this.state.color}</p>\r\n     </div>\r\n   );\r\n }\r\n}\r\n\r\n```\r\n\r\nAs one can see in the code above, we can use the state by calling this.state.propertyName and we can change the state object property using setState method.\r\n\r\n### React Props {#React-Props}\r\n\r\nEvery react component, accepts a single object argument called props (which stands for “properties”).\r\n\r\nThese props can be passed to a component using HTML attributes.\r\n\r\nUsing props, we can pass data from one component to another.\r\n\r\n- While rendering a component, we can pass the props as a HTML attribute:\r\n\r\n```\r\n<Car brand=\"Mercedes\"/>\r\n```\r\n\r\nThe component receives the props:\r\n\r\n- In Class component:\r\n\r\n```\r\nclass Car extends React.Component {\r\n constructor(props) {\r\n   super(props);\r\n   this.state = {\r\n     brand: this.props.brand,\r\n     color: \"Black\"\r\n   };\r\n }\r\n}\r\n```\r\n\r\n- In Functional component:\r\n\r\n```\r\nfunction Car(props) {\r\n  render() {\r\n      return <h1>Name is {props.name}!</h1>;\r\n   }\r\n}\r\n```\r\n\r\n**Note- Props are read-only. They cannot be manipulated or changed inside a component**\r\n\r\n## Explain React Hooks? {#Explain-React-Hooks}\r\n\r\nHooks are functions that let us “hook into” React state and lifecycle features from a `functional component.`\r\nReact Hooks cannot be used in class components.\r\n\r\nWhy were Hooks introduced in React?\r\nReact hooks were introduced in the 16.8 version of React.\r\nPreviously, functional components were called stateless components. Only class components were used for state management and lifecycle methods.\r\n\r\nThe need to change a functional component to a class component, whenever state management or lifecycle methods were to be used, led to the development of Hooks.\r\n\r\n**Example of a hook:**\r\n\r\n`useState hook:`\r\nIn functional components, useState hook lets us define state for a component:\r\n\r\n```\r\nfunction Person(props) {\r\n // We are declaring a state variable called name.\r\n // setName is a function to update/change the value of name\r\n let [name, setName] = useState('');\r\n}\r\n```\r\n\r\n## What are the different lifecycle methods in React? {#What-are-the-different-lifecycle-methods-in-React}\r\n\r\nEach component in react goes through three phases: `Mounting`, `Updating`, and `Unmounting`.\r\n\r\n- **Mounting** :- Birth of your component\r\n- **Update** :- Growth of your component\r\n- **Unmount** :- Death of your component\r\n\r\n![React Life Cycle Methods](/BL-1003/ReactLifeCycle.png)\r\n\r\n### Common React Lifecycle Methods {#Common-React-Lifecycle-Methods}\r\n\r\n- **constructor()**\r\n\r\nThis is used only if you have a class-based Component and it serves the purpose of initializing the state of a Component. In case of functional Components, the useState() hook is used to do the same.\r\n\r\n- **render()**\r\n\r\nThis is the method that is `responsible for inserting a Component into the DOM`.\r\n\r\nThe render() method is the most used lifecycle method. This is because render() is the only required method within a class component in React.\r\n\r\nIt happens during the `mounting` and `updating` of your component.\r\n\r\n```\r\nBelow is an example of a simple render() in React.\r\n\r\nclass Hello extends Component{\r\n   render(){\r\n      return <div>Hello {this.props.name}</div>\r\n   }\r\n}\r\n\r\n```\r\n\r\n**A render() can also return a null if there is nothing to render for that component.**\r\n\r\n- **componentDidMount()**\r\n\r\nThis is invoked `after a Component is inserted into the DOM for the first time`.\r\n\r\nWhen component has been mounted and ready, that’s when the next React lifecycle method componentDidMount() comes in play.\r\n\r\ncomponentDidMount() is called as soon as the component is mounted and ready. This is a good place to initiate API calls, if you need to load data from a remote endpoint.\r\n\r\n`componentDidMount() allows the use of setState()`.\r\n\r\n- **componentDidUpdate()**\r\n\r\nThis is the method invoked after `re-rendering an updated Component`. This method can give you the information about a Component’s previous state and previous props. This lifecycle method is invoked as soon as the updating happens. The most common use case for the componentDidUpdate() method is updating the DOM in response to prop or state changes.\r\n\r\nYou can call setState() in this lifecycle, but keep in mind that you will need to wrap it in a condition to check for state or prop changes from previous state. Incorrect usage of setState() can lead to an infinite loop.\r\n\r\n```\r\nTake a look at the example below that shows a typical usage example of this lifecycle method.\r\n\r\ncomponentDidUpdate(prevProps) {\r\n//Typical usage, don't forget to compare the props\r\nif (this.props.userName !== prevProps.userName) {\r\nthis.fetchData(this.props.userName);\r\n}\r\n}\r\n\r\n```\r\n\r\nNotice in the above example that we are comparing the current props to the previous props. This is to check if there has been a change in props from what it currently is. In this case, there won’t be a need to make the API call if the props did not change.\r\n\r\n- **componentWillUnmount()**\r\n\r\nAs the name suggests this lifecycle method is called just `before the component is unmounted and destroyed`.\r\n\r\nYou cannot modify the component state in componentWillUnmount lifecycle.\r\n\r\nThis is where you can perform any cleanups that need to be done such as invalidating timers, canceling network requests, removing event listeners, and so on.\r\n\r\n```\r\ncomponentWillUnmount() {\r\nwindow.removeEventListener('resize', this.resizeListener)\r\n}\r\n```\r\n\r\n## What are keys in React? {#What-are-keys-in-React}\r\n\r\nA key is a special string attribute that needs to be included when using lists of elements.\r\n\r\nExample of a list using key:\r\n\r\n```\r\nconst ids = [1,2,3,4,5];\r\nconst listElements = ids.map((id)=>{\r\nreturn(\r\n <li key={id.toString()}>\r\n   {id}\r\n </li>\r\n )\r\n})\r\n```\r\n\r\n**Importance of keys:-**\r\n\r\n- Keys help react identify which elements were added, changed or removed.\r\n- Keys should be given to array elements for providing a unique identity for each element.\r\n- Without keys, React does not understand the order or uniqueness of each element.\r\n- With keys, React has an idea of which particular element was deleted,edited, and added.\r\n\r\n## React pure component {#React-pure-component}\r\n\r\nA React component is considered pure if it renders the same output for the same state and props. For class components like this, React provides the PureComponent base class. Class components that extend the `React.PureComponent` class are treated as `pure components`.\r\n\r\nPure components have some performance improvements and render optimizations since React implements the shouldComponentUpdate() method for them with a shallow comparison for props and state.\r\n\r\n**Features of React Pure Components**\r\n\r\n- Prevents re-rendering of Component if props or state is the same\r\n- Takes care of “shouldComponentUpdate” implicitly\r\n- State and Props are Shallow Compared\r\n- Pure Components are more performant in certain cases\r\n\r\n**React Components re-renders in the following scenarios:**\r\n\r\n- “setState” is called in Component\r\n- “props” values are updated\r\n- this.forceUpdate() is called\r\n\r\n`In the case of Pure Components, the React components do not re-render blindly without considering the updated values of React “props” and “state”. If updated values are the same as previous values, render is not triggered.`\r\n","readTime":{"text":"10 min read","minutes":9.235,"time":554100,"words":1847}},{"data":{"Id":1004,"Title":"Rough","Author":"Soumyajit","Tags":"Interview Javascript","Topic":"Javascript","Abstract":"Learning some of the fundamental concepts of Javascript and top questions asked in javascript interview.","HeaderImage":"/BL-1001/header.jpg","isPublished":false},"content":"\r\n## Global vs Local Scope {#Global-vs-Local-Scope}\r\n\r\n## Async Defer\r\n\r\n## Event bubbling capturing\r\n\r\n## Event Throtting and debouncing\r\n","readTime":{"text":"1 min read","minutes":0.09,"time":5400,"words":18}},{"data":{"Id":1005,"Title":"Understanding Promises in Javasript","Author":"Soumyajit","Tags":"Javascript Interview","Topic":"Javascript","Abstract":"Learning about Promises in Javascript","HeaderImage":"/BL-1005/header.png","isPublished":true},"content":"\r\n## What is a Promise in JavaScript {#What-is-a-Promise-in-JavaScript}\r\n\r\nA Promise is a special JavaScript object. It produces a value after an asynchronous operation completes successfully, or an error if it does not complete successfully due to time out, network error, and so on.\r\n\r\n## Creating a JavaScript Promise {#Creating-a-JavaScript-Promise}\r\n\r\nWhen the task completes, you either fulfill your promise or fail to do so.\r\nPromise is a constructor function, so you need to use the `new keyword` to create one. It takes a function, as its argument, with two parameters - `resolve and reject`. These are methods used to determine the outcome of the promise.\r\n\r\n```\r\nCreating a Promise\r\n\r\nconst myPromise = new Promise((resolve, reject) => {\r\n});\r\n```\r\n\r\n## Promise States {#Promise-States}\r\n\r\nA promise has three states: `pending, fulfilled, and rejected.` The resolve and reject parameters given to the promise argument are used to do this. resolve is used when you want your promise to succeed, and reject is used when you want it to fail. These are methods that take an argument, as seen below.\r\n\r\n- **Pending: Initially when the executor function starts the execution.**\r\n- **Fulfilled: When the promise is resolved.**\r\n- **Rejected: When the promise is rejected.**\r\n\r\n![Promise States](/BL-1005/states.png)\r\n\r\n```\r\nconst myPromise = new Promise((resolve, reject) => {\r\n if(condition here) {\r\n   resolve(\"Promise was fulfilled\");\r\n } else {\r\n   reject(\"Promise was rejected\");\r\n }\r\n});\r\n```\r\n\r\n## Handling a Promise {#Handling-a-Promise}\r\n\r\n![Promise Handling](/BL-1005/handling.png)\r\n\r\n### Handling Promises With Then Method {#Handling-Promises-With-Then-Method}\r\n\r\nPromises are most useful when you have a process that takes an unknown amount of time in your code (i.e. something asynchronous), often a server request. When you make a server request it takes some amount of time, and after it completes you usually want to do something with the response from the server. This can be achieved by using the then method. The then method is executed immediately after your promise is fulfilled with resolve.\r\n\r\n```\r\nmyPromise.then(result => {\r\n\r\n});\r\n```\r\n\r\n### Handling a Rejected Promise with Catch Method {#Handling-a-Rejected-Promise-with-Catch-Method}\r\n\r\nCatch is the method used when your promise has been rejected. It is executed immediately after a promise's reject method is called.\r\n\r\n```\r\nmyPromise.catch(error => {\r\n\r\n});\r\n```\r\n\r\n## Async Await {#Async-Await}\r\n\r\nAsync/await are special syntax to work with promises in a more comfortable fashion.\r\n\r\n- **async makes a function return a Promise**\r\n- **await makes a function wait for a Promise**\r\n\r\n### Async {#Async}\r\n\r\n```\r\nExample\r\nasync function myFunction() {\r\n  return \"Hello\";\r\n}\r\n\r\nIs the same as:\r\nasync function myFunction() {\r\n  return Promise.resolve(\"Hello\");\r\n}\r\n```\r\n\r\n### Await {#Await}\r\n\r\nThe keyword await makes JavaScript wait until that promise settles and returns its result.\r\nThe `await keyword` can only be used inside an `async` function.\r\n\r\n```\r\nasync function f() {\r\n\r\n  let promise = new Promise((resolve, reject) => {\r\n    setTimeout(() => resolve(\"done!\"), 1000)\r\n  });\r\n\r\n  let result = await promise; // wait until the promise resolves (*)\r\n\r\n  alert(result); // \"done!\"\r\n}\r\n```\r\n\r\nThe function execution \"pauses\" at the line (\\*) and resumes when the promise settles, with result becoming its result.\r\n\r\n## Implement Promise {#Implement-Promise}\r\n\r\n```\r\nconst pr1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    resolve(\"hello\");\r\n  }, 4000);\r\n});\r\n\r\nconst pr2 = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    resolve(\"world\");\r\n  }, 0);\r\n});\r\n\r\nconst fun = async () => {\r\n  try {\r\n    const res = await Promise.all([pr1, pr2]);\r\n    console.log(res);\r\n  } catch (err) {\r\n    console.log(err);\r\n  }\r\n};\r\n\r\nfun();\r\n```\r\n\r\n**References:**\r\n\r\n- <a href=\"https://www.freecodecamp.org/news/javascript-promise-tutorial-how-to-resolve-or-reject-promises-in-js/\" target=\"_blank\">JavaScript Promise Tutorial</a>\r\n- <a href=\"https://www.w3schools.com/js/js_async.asp\" target=\"_blank\">Async/Await</a>\r\n","readTime":{"text":"3 min read","minutes":2.85,"time":171000,"words":570}},{"data":{"Id":1006,"Title":"Javascript Concepts - Part1","Author":"Soumyajit","Tags":"Javascript Interview","Topic":"Javascript","Abstract":"Learning some of the fundamental concepts of Javascript and questions asked in javascript interview.","HeaderImage":"/BL-1006/header.png","isPublished":true},"content":"\r\n## New Features in ES6 {#New-Features-in-ES6}\r\n\r\nSome of the new features of javascript introductes in ES6 are:\r\n\r\n- The Let keyword\r\n- The Const keyword\r\n- Arrow Functions\r\n- Promises\r\n- Map Object\r\n\r\n```\r\n// Create a new Map\r\nconst fruits = new Map();\r\n\r\n// Add new Elements to the Map\r\nfruits.set(apples, 500);\r\nfruits.set(bananas, 300);\r\nfruits.set(oranges, 200);\r\n```\r\n\r\n- Set Object\r\n\r\n```\r\n// Create a Set\r\nconst letters = new Set();\r\n\r\n// Add some values to the Set\r\nletters.add(\"a\");\r\nletters.add(\"b\");\r\nletters.add(\"c\");\r\n```\r\n\r\n- Classes\r\n\r\n```\r\nclass ClassName {\r\n  constructor() { ... }\r\n}\r\n\r\n// Example\r\nclass Car {\r\n  constructor(name, year) {\r\n    this.name = name;\r\n    this.year = year;\r\n  }\r\n}\r\n```\r\n\r\n## Difference between Let and Var and Const {#Difference-between-Let-and-Var-and-Const}\r\n\r\n### Comparision of Declarations {#Comparision-of-Declarations}\r\n\r\nOne of the biggest problems with declaring variables with the var keyword is that you can easily overwrite variable declarations:\r\n\r\n```\r\nvar camper = \"James\";\r\nvar camper = \"David\";\r\nconsole.log(camper);\r\n```\r\n\r\nIn the code above, the camper variable is originally declared as James, and is then overridden to be David. The console then displays the string David.\r\n\r\nIf you replace var with let in the code above, it results in an error:\r\n\r\n```\r\nlet camper = \"James\";\r\nlet camper = \"David\";\r\nThe error can be seen in your browser console.(Uncaught SyntaxError: Identifier 'camper' has already been declared)\r\n```\r\n\r\n`So unlike var, when you use let, a variable with the same name can only be declared once.`\r\n\r\n### Comparision of scopes of the var and let Keywords {#Comparision-of-scopes-of-the-var-and-let-Keywords}\r\n\r\nWhen you declare a variable with the var keyword, it is declared globally.\r\nThe let keyword behaves similarly, but with some extra features. When you declare a variable with the let keyword inside a block, statement, or expression, its scope is limited to that block, statement, or expression.\r\n\r\n```\r\nvar numArray = [];\r\nfor (var i = 0; i < 3; i++) {\r\n  numArray.push(i);\r\n}\r\nconsole.log(numArray);\r\nconsole.log(i);\r\nHere the console will display the values [0, 1, 2] and 3.\r\n```\r\n\r\nWith the var keyword, i is declared globally. So when i++ is executed, it updates the global variable.\r\n\r\nThis behavior will cause problems if you were to create a function and store it for later use inside a for loop that uses the i variable. This is because the stored function will always refer to the value of the updated global i variable.\r\n\r\n```\r\nvar printNumTwo;\r\nfor (var i = 0; i < 3; i++) {\r\n  if (i === 2) {\r\n    printNumTwo = function() {\r\n      return i;\r\n    };\r\n  }\r\n}\r\nconsole.log(printNumTwo());\r\nHere the console will display the value 3.\r\n```\r\n\r\nAs you can see, printNumTwo() prints 3 and not 2. This is because the value assigned to i was updated and the printNumTwo() returns the global i and not the value i had when the function was created in the for loop.\r\n\r\nThe let keyword does not follow this behavior:\r\n\r\n```\r\nlet printNumTwo;\r\nfor (let i = 0; i < 3; i++) {\r\n    if (i === 2) {\r\n        printNumTwo = function() {\r\n            return i;\r\n        };\r\n    }\r\n}\r\nconsole.log(printNumTwo());\r\nconsole.log(i);\r\n```\r\n\r\nHere the console will display the value 2, and an error that i is not defined. i is not defined because it was not declared in the global scope. It is only declared within the for loop statement. printNumTwo() returned the correct value because three different i variables with unique values (0, 1, and 2) were created by the let keyword within the loop statement.\r\n\r\n### Const {#Const}\r\n\r\nWhile var and let can be declared without being initialized, const must be initialized during declaration.\r\n`Const cannot be initialized after declaritions`\r\n\r\nHowever, it is important to understand that objects (including arrays and functions) assigned to a variable using const are still mutable. Using the `const declaration only prevents reassignment of the variable identifier.`\r\n\r\n```\r\nconst s = [5, 6, 7];\r\ns = [1, 2, 3];\r\ns[2] = 45;\r\nconsole.log(s);\r\nThe console.log will display the value [5, 6, 45].\r\n\r\ns = [1, 2, 3] will result in an error.\r\n```\r\n\r\nAs you can see, you can mutate the object [5, 6, 7] itself and the variable s will still point to the altered array [5, 6, 45]. Like all arrays, the array elements in s are mutable, but because const was used, you cannot use the variable identifier s to point to a different array using the assignment operator.\r\n\r\n## Variable shadowing {#Variable-shadowing}\r\n\r\n```\r\nlet number = 10;\r\n\r\nfunction displayDouble() {\r\n  //new variable is defined with the same name as variable on line 1 - outer scope\r\n  let number = 3;\r\n\r\n  number *= 2;\r\n  console.log(number); //=> 6\r\n}\r\n\r\ndisplayDouble();\r\nconsole.log(number); //=> 10\r\n```\r\n\r\nIn this case, both variables on line 1 and 5 are defined with the same name — number.This has a significant result: the variable defined in the outer scope is ‘shadowed’ by the variable defined in the inner scope.\r\n\r\n## String in Javascript {#String-in-Javascript}\r\n\r\nIn JavaScript, String values are immutable, which means that they cannot be altered once created.\r\n\r\nFor example, the following code:\r\n\r\nlet myStr = \"Bob\";\r\nmyStr[0] = \"J\";\r\ncannot change the value of myStr to Job, because the contents of myStr cannot be altered.\r\n\r\n## Escape Sequences in Strings {#Escape-Sequences-in-Strings}\r\n\r\n```\r\nCode   Output\r\n\\' single quote\r\n\\\" double quote\r\n\\\\ backslash\r\n\\n newline\r\n\\r carriage return\r\n\\t tab\r\n\\b word boundary\r\n\\f form feed\r\n```\r\n\r\n## Difference between '==' and '===' in javascript {#Difference-between-==-and-===-in-javascript}\r\n\r\nStrict equality (===) is the counterpart to the equality operator (==). However, unlike the equality operator, which attempts to convert both values being compared to a common type, the strict equality operator does not perform a type conversion.\r\n\r\nIf the values being compared have different types, they are considered unequal, and the strict equality operator will return false.\r\n\r\n```\r\nExamples 1:\r\n\r\n3 === 3 //true\r\n3 === '3' // false\r\n1 == [1] //true\r\n1 === [1] //false\r\nnull == undefined //true\r\n```\r\n\r\n```\r\nExample 2:‌\r\nconst number = 1234\r\nconst stringNumber = '1234'\r\n\r\nconsole.log(number == stringNumber) //true\r\nconsole.log(number === stringNumber)  //false\r\n```\r\n\r\nThe value of number and stringNumber looks similar here. However, the type of number is Number and type of stringNumber is string. Even though the values are same, the type is not the same. Hence a == check returns true, but when checked for value and type, the value is false.\r\n\r\n```\r\nExample 3:\r\nconsole.log(0 == false) //true\r\nconsole.log(0 === false) //false\r\nReason: same value, different type. Type coercion\r\n```\r\n\r\nThis is an interesting case. The value of 0 when checked with false is same. It is so because 0 and false have the same value for JavaScript, but when checked for type and value, the value is false because 0 is a number and false is boolean.\r\n\r\n```\r\nExample 4:\r\nconst str = \"\"\r\n\r\nconsole.log(str == false) //true\r\nconsole.log(str === false) //false\r\n```\r\n\r\nThe value of empty string and false is same in JavaScript. Hence, == returns true. However, the type is different and hence === returns false.\r\n\r\n```\r\nExample 5:\r\nlet obj1 = { a: 1, b: 2 };\r\nlet obj2 = { a: 1, b: 2 };\r\nconsole.log(obj1 == obj2); //false\r\nconsole.log(obj1 === obj2); //false\r\n```\r\n\r\nThe important thing to understand here is that the variables, obj1 and obj2 (which could be an Object, Array or Function) each contain only a reference to a location in memory. Not the value of the object.\r\n\r\n## Explain how this works in JavaScript {#Explain-how-this-works-in-JavaScript}\r\n\r\nTo access a property of an object from within a method of the same object, you need to use the this keyword.\r\n\r\n```\r\nconst person = {\r\n    name: 'John',\r\n    age: 30,\r\n\r\n    // accessing name property by using this.name\r\n    greet: function() { console.log('The name is' + ' ' + this.name); }\r\n};\r\n\r\nperson.greet();\r\n```\r\n\r\nIn the above example, a person object is created. It contains properties (name and age) and a method greet.\r\nIn the method greet, while accessing a property of an object, this keyword is used.\r\nIn order to access the properties of an object, this keyword is used following by . and key.\r\n\r\nThis keyword refers to the `object where it is called.`\r\n\r\n### 1 this Inside Global Scope {#1-this-Inside-Global-Scope}\r\n\r\nWhen this is used alone, this refers to the global object (window object in browsers). For example,\r\n\r\n```\r\nlet a = this;\r\nconsole.log(a);  // Window {}\r\n\r\nthis.name = 'Sarah';\r\nconsole.log(window.name); // Sarah\r\n```\r\n\r\n### 2 this Inside Function {#2-this-Inside-Function}\r\n\r\nWhen this is used in a function, this refers to the global object (window object in browsers). For example,\r\n\r\n```\r\nfunction greet() {\r\n    // this inside function\r\n    // this refers to the global object\r\n    console.log(this);\r\n}\r\ngreet(); // Window {}\r\n```\r\n\r\n### 3 this Inside Constructor Function {#3-this-Inside-Constructor-Function}\r\n\r\nIn JavaScript, constructor functions are used to create objects. When a function is used as a constructor function, this refers to the object inside which it is used. For example,\r\n\r\n```\r\nfunction Person() {\r\n    this.name = 'Jack';\r\n    console.log(this);\r\n}\r\n\r\nlet person1 = new Person();\r\nconsole.log(person1.name);\r\n```\r\n\r\nHere, this refers to the person1 object. That's why, person1.name gives us Jack.\r\nWhen this is used with ES6 classes, it refers to the object inside which it is used.\r\n\r\nFor example,\r\n\r\n```\r\n// creating a class\r\nclass Person {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n}\r\nThe class keyword is used to create a class. The properties are assigned in a constructor function.\r\n\r\n// creating a class\r\nclass Person {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n}\r\n\r\n// creating an object\r\nconst person1 = new Person('John');\r\nconst person2 = new Person('Jack');\r\n\r\nconsole.log(person1.name); // John\r\nconsole.log(person2.name); // Jack\r\n```\r\n\r\n### 4 this Inside Object Method {#4-this-Inside-Object-Method}\r\n\r\nWhen this is used inside an object's method, this refers to the object it lies within. For example,\r\n\r\n```\r\nconst person = {\r\nname : 'Jack',\r\nage: 25,\r\n    // this inside method\r\n    // this refers to the object itself\r\n    greet() {\r\n        console.log(this);\r\n        console.log(this.name);\r\n    }\r\n\r\n}\r\n\r\nperson.greet();\r\nOutput\r\n{name: \"Jack\", age: 25, greet: ƒ}\r\nJack\r\n```\r\n\r\n### 5 this Inside Inner Function {#5-this-Inside-Inner-Function}\r\n\r\nWhen you access this inside an inner function (inside a method), this refers to the global object. For example,\r\n\r\n```\r\nconst person = {\r\nname : 'Jack',\r\nage: 25,\r\n\r\n    // this inside method\r\n    // this refers to the object itself\r\n    greet() {\r\n        console.log(this);        // {name: \"Jack\", age ...}\r\n        console.log(this.age);  // 25\r\n\r\n        // inner function\r\n        function innerFunc() {\r\n            // this refers to the global object\r\n            console.log(this);       // Window { ... }\r\n            console.log(this.age);    // undefined\r\n        }\r\n        innerFunc();\r\n    }\r\n}\r\nperson.greet();\r\n```\r\n\r\n### 6 this Inside Arrow Function {#6-this-Inside-Arrow-Function}\r\n\r\nInside the arrow function, this refers to the parent scope. For example,\r\n\r\n```\r\nconst greet = () => {\r\n    console.log(this);\r\n}\r\ngreet(); // Window {...}\r\n```\r\n\r\n`Arrow functions do not have their own this`. When you use this inside an arrow function, this refers to its parent scope object.\r\nFor example,\r\n\r\n```\r\nconst greet = {\r\n    name: 'Jack',\r\n\r\n    // method\r\n    sayHi () {\r\n        let hi = () => console.log(this.name);\r\n        hi();\r\n    }\r\n}\r\ngreet.sayHi(); // Jack\r\n```\r\n\r\n```\r\nconst person = {\r\n    name : 'Jack',\r\n    age: 25,\r\n\r\n    // this inside method\r\n    // this refers to the object itself\r\n    greet() {\r\n        console.log(this);\r\n        console.log(this.age);\r\n\r\n        // inner function\r\n        let innerFunc = () => {\r\n\r\n            // this refers to the global object\r\n            console.log(this);\r\n            console.log(this.age);\r\n        }\r\n        innerFunc();\r\n    }\r\n}\r\n\r\nperson.greet();\r\n\r\nOutput:\r\n{name: \"Jack\", age: 25, greet: ƒ}\r\n25\r\n{name: \"Jack\", age: 25, greet: ƒ}\r\n25\r\nHere, innerFunc() is defined using the arrow function. It takes this from its parent scope. Hence, this.age gives 25.\r\n```\r\n\r\n### 7 this Inside Function with Strict Mode {#7-this-Inside-Function-with-Strict-Mode}\r\n\r\nWhen this is used in a function with strict mode, this is undefined. For example,\r\n\r\n```\r\n'use strict';\r\nthis.name = 'Jack';\r\nfunction greet() {\r\n\r\n    // this refers to undefined\r\n    console.log(this);\r\n}\r\ngreet(); // undefined\r\n```\r\n\r\n## How is arrow functions different from normal functions in javascript {#How-is-arrow-functions-different-from-normal-functions-in-javascript}\r\n\r\n### this Keyword {#this-Keyword}\r\n\r\nInside a `regular function, this keyword refers to the function` where it is called.\r\n\r\nHowever, `this is not associated with arrow functions`. `Arrow function does not have its own this`. So whenever you call this, it refers to its parent scope.\r\n\r\n**Inside a regular function**\r\n\r\n```\r\nfunction Person() {\r\n    this.name = 'Jack',\r\n    this.age = 25,\r\n    this.sayName = function () {\r\n\r\n        // this is accessible\r\n        console.log(this.age);\r\n\r\n        function innerFunc() {\r\n            // this refers to the global object\r\n            console.log(this.age);\r\n            console.log(this);\r\n        }\r\n        innerFunc();\r\n    }\r\n}\r\n\r\nlet x = new Person();\r\nx.sayName();\r\n\r\nOutput:\r\n25\r\nundefined\r\nWindow {}\r\n```\r\n\r\nHere, this.age inside this.sayName() is accessible because this.sayName() is the method of an object.\r\n\r\nHowever, innerFunc() is a normal function and this.age is not accessible because this refers to the global object (Window object in the browser). Hence, this.age inside the innerFunc() function gives undefined.\r\n\r\n**Inside an arrow function**\r\n\r\n```\r\nfunction Person() {\r\n    this.name = 'Jack',\r\n    this.age = 25,\r\n    this.sayName = function () {\r\n\r\n        console.log(this.age);\r\n        let innerFunc = () => {\r\n            console.log(this.age);\r\n        }\r\n        innerFunc();\r\n    }\r\n}\r\n\r\nconst x = new Person();\r\nx.sayName();\r\n\r\nOutput\r\n25\r\n25\r\n```\r\n\r\nHere, the innerFunc() function is defined using the arrow function. And inside the arrow function, this refers to the parent's scope. Hence, this.age gives 25.\r\n\r\n### Arguments Binding {#Arguments-Binding}\r\n\r\n`Regular functions have arguments binding`. That's why when you pass arguments to a regular function, you can access them using the arguments keyword.\r\n\r\n```\r\nlet x = function () {\r\n    console.log(arguments);\r\n}\r\nx(4,6,7); // Arguments [4, 6, 7]\r\n```\r\n\r\n`Arrow functions do not have arguments binding`.\r\nWhen you try to access an argument using the arrow function, it will give an error. For example,\r\n\r\n```\r\nlet x = () => {\r\n    console.log(arguments);\r\n}\r\nx(4,6,7);\r\n// ReferenceError: Can't find variable: arguments\r\n```\r\n\r\nTo solve this issue, you can use the spread syntax.\r\n\r\n```\r\nlet x = (...n) => {\r\n  console.log(n);\r\n}\r\nx(4,6,7); // [4, 6, 7]\r\n```\r\n","readTime":{"text":"12 min read","minutes":11.39,"time":683400,"words":2278}},{"data":{"Id":1007,"Title":"Javascript Concepts - Part2","Author":"Soumyajit","Tags":"Javascript Interview","Topic":"Javascript","Abstract":"Learning some of the fundamental concepts of Javascript and questions asked in javascript interview.","HeaderImage":"/BL-1006/header.png","isPublished":true},"content":"\r\n## Explain \"hoisting\" {#Explain-hoisting}\r\n\r\nHoisting is JavaScript's default behavior of moving all declarations to the top of the current scope.\r\nNote that the declaration is not actually moved - the JavaScript engine parses the declarations during compilation and becomes aware of declarations and their scopes.\r\n\r\n```\r\nconsole.log(foo); // undefined\r\nvar foo = 1;\r\nconsole.log(foo); // 1\r\n```\r\n\r\nFunction declarations have the body hoisted while the function expressions only has the variable declaration hoisted.\r\n\r\n```\r\n// Function Declaration\r\nconsole.log(foo); // [Function: foo]\r\nfoo(); // 'FOOOOO'\r\nfunction foo() {\r\n  console.log('FOOOOO');\r\n}\r\nconsole.log(foo); // [Function: foo]\r\n\r\n// Function Expression\r\nconsole.log(bar); // undefined\r\nbar(); // Uncaught TypeError: bar is not a function\r\nvar bar = function () {\r\n  console.log('BARRRR');\r\n};\r\nconsole.log(bar); // [Function: bar]\r\n```\r\n\r\nVariables defined with let and const are hoisted to the top of the block, but not initialized.Meaning that the block of code is aware of the variable, but it cannot be used until it has been declared.\r\n\r\n## What is a closure {#What-is-a-closure}\r\n\r\nJavaScript implements a scoping mechanism named lexical scoping (or static scoping). Lexical scoping means that the accessibility of variables is determined by the position of the variables inside the nested scopes.\r\n\r\nSimpler, the lexical scoping means that inside the inner scope you can access variables of outer scopes.\r\n\r\n**Closures are functions that have access to the outer (enclosing) function's variables scope even after the outer function has returned.**\r\n\r\n```\r\nfunction outerFunc() {\r\n  let outerVar = 'I am outside!';\r\n  function innerFunc() {\r\n    console.log(outerVar); // => logs \"I am outside!\"\r\n  }\r\n  return innerFunc;\r\n}\r\nfunction exec() {\r\n  const myInnerFunc = outerFunc();\r\n  myInnerFunc();\r\n}\r\nexec();\r\n```\r\n\r\nNow innerFunc() is executed outside of its lexical scope, but exactly in the scope of exec() function. And what's important:\r\ninnerFunc() still has access to outerVar from its lexical scope, even being executed outside of its lexical scope.\r\n\r\n## JavaScript Rest vs Spread Operator {#JavaScript-Rest-vs-Spread-Operator}\r\n\r\n### Rest Operator {#Rest-Operator}\r\n\r\n**The rest operator (...) is used to put the rest of some specific user-supplied values into a JavaScript array.**\r\n\r\nFor instance, consider this code that uses rest to enclose some values into an array:\r\n\r\n```\r\n// Use rest to enclose the rest of specific user-supplied values into an array:\r\nfunction myBio(firstName, lastName, ...otherInfo) {\r\n  return otherInfo;\r\n}\r\n\r\n// Invoke myBio function while passing five arguments to its parameters:\r\nmyBio(\"Oluwatobi\", \"Sofela\", \"CodeSweetly\", \"Web Developer\", \"Male\");\r\n\r\n// The invocation above will return:\r\n[\"CodeSweetly\", \"Web Developer\", \"Male\"]\r\n```\r\n\r\n### Spread Operator {#Spread-Operator}\r\n\r\n**The spread operator (...) helps you expand iterables into individual elements.**\r\nA spread operator is effective only when used within array literals, function calls, or initialized properties objects.\r\n\r\n### Example 1: How Spread Works in an Array Literal {#Example-1-How-Spread-Works-in-an-Array-Literal}\r\n\r\n```\r\nconst myName = [\"Sofela\", \"is\", \"my\"];\r\nconst aboutMe = [\"Oluwatobi\", ...myName, \"name.\"];\r\n\r\nconsole.log(aboutMe);\r\n\r\n// The invocation above will return:\r\n[ \"Oluwatobi\", \"Sofela\", \"is\", \"my\", \"name.\" ]\r\n```\r\n\r\nSuppose we did not use the spread syntax to duplicate myName’s content. For instance, if we had written const aboutMe = [\"Oluwatobi\", myName, \"name.\"]. In such a case, the computer would have assigned a reference back to myName\r\n\r\n### Example 2: How to Use Spread to Convert a String into Individual Array Items {#Example-2-How-to-Use-Spread-to-Convert-a-String-into-Individual-Array-Items}\r\n\r\n```\r\nconst myName = \"Oluwatobi Sofela\";\r\n\r\nconsole.log([...myName]);\r\n\r\n// The invocation above will return:\r\n[ \"O\", \"l\", \"u\", \"w\", \"a\", \"t\", \"o\", \"b\", \"i\", \" \", \"S\", \"o\", \"f\", \"e\", \"l\", \"a\" ]\r\n```\r\n\r\n### Example 3: How the Spread Operator Works in a Function Call {#Example-3-How-the-Spread-Operator-Works-in-a-Function-Call}\r\n\r\n```\r\nconst numbers = [1, 3, 5, 7];\r\n\r\nfunction addNumbers(a, b, c, d) {\r\n  return a + b + c + d;\r\n}\r\n\r\nconsole.log(addNumbers(...numbers));\r\n\r\n// The invocation above will return:\r\n16\r\n```\r\n\r\nSuppose the numbers array had more than four items. In such a case, the computer will only use the first four items as addNumbers() argument and ignore the rest.\r\n\r\n```\r\nconst numbers = [1, 3, 5, 7, 10, 200, 90, 59];\r\n\r\nfunction addNumbers(a, b, c, d) {\r\n  return a + b + c + d;\r\n}\r\n\r\nconsole.log(addNumbers(...numbers));\r\n\r\n// The invocation above will return:\r\n16\r\n```\r\n\r\n### Example 4: How Spread Works in an Object Literal {#Example-4-How-Spread-Works-in-an-Object-Literal}\r\n\r\n```\r\nconst myNames = [\"Oluwatobi\", \"Sofela\"];\r\nconst bio = { ...myNames, runs: \"codesweetly.com\" };\r\n\r\nconsole.log(bio);\r\n\r\n// The invocation above will return:\r\n\r\n{ 0: \"Oluwatobi\", 1: \"Sofela\", runs: \"codesweetly.com\" }\r\n```\r\n\r\n- Spread operators can’t expand object literal’s values\r\n- Since a properties object is not an iterable object, you cannot use the spread operator to expand its values.\r\n- However, you can use the spread operator to clone properties from one object into another.\r\n\r\n```\r\nconst myName = { firstName: \"Oluwatobi\", lastName: \"Sofela\" };\r\nconst bio = { ...myName, website: \"codesweetly.com\" };\r\n\r\nconsole.log(bio);\r\n\r\n// The invocation above will return:\r\n{ firstName: \"Oluwatobi\", lastName: \"Sofela\", website: \"codesweetly.com\" };\r\n```\r\n\r\n## Pure vs Impure Functions in JavaScript {#Pure-vs-Impure-Functions-in-JavaScript}\r\n\r\n1. Pure Functions:\r\n\r\n- They must be predictable\r\n- They must have no side effects\r\n\r\nIdentical inputs will always return identical outputs, no matter how many times a pure function is called.\r\n\r\n2.  Impure Function:\r\n\r\n- Unpredictable\r\n- Has side-effects\r\n\r\nSide Effects can be:-\r\n\r\n- **Modifying a global variable**\r\n- **Modifying an argument**\r\n- **External dependency (APIs, outer variables)**\r\n- **DOM manipulation**\r\n- **Reading/writing files**\r\n\r\n```\r\n//IMPURE FUNCTION\r\nconst impureAddToArray = (arr1, num) => {\r\n  //altering arr1 in-place by pushing\r\n  arr1.push(num);\r\n  return arr1;\r\n};\r\n\r\n// PURE FUNCTION\r\n// Adding a value to an array via a pure function instead can be achieved using the spread operator, which makes a copy of the original array without mutating it.\r\n\r\nconst pureAddToArray = (arr1, num) => {\r\n  return [...arr1, num];\r\n};\r\n```\r\n\r\n```\r\n// IMPURE FUNCTION\r\nconst impureAddToObj = (obj, key, val) => {\r\n  obj[key] = val;\r\n  return obj;\r\n};\r\n\r\nBecause we're modifying the object in-place, the above approach is considered impure. Below is its pure counterpart, utilising the spread operator again.\r\n\r\n// PURE FUNCTION\r\nconst  pureAddToObj = (obj, key, val) => {\r\n  return { ...obj, [key]: val };\r\n}\r\n```\r\n\r\n## Higher Order Functions {#Higher-Order-Functions}\r\n\r\nA higher order function is a function that takes a function as an argument, or returns a function.\r\n\r\n- Some examples of higher order functions are .map() , .filter() and .reduce(). Both of them take a function as an argument.\r\n\r\n### Map Method {#Map-Method}\r\n\r\nUsing map method in javaScript creates an array by calling a specific function on each element present in the parent array.It returns a new array and elements of arrays are result of callback function.\r\n\r\n```\r\nSyntax:\r\narr.map(function(element, index, array){  }, this);\r\nThe this argument will be used inside the callback function. By default, its value is undefined .\r\n```\r\n\r\n```\r\nExample:\r\nlet arr = [2, 3, 5, 7]\r\n\r\narr.map(function(element, index, array){\r\n\tconsole.log(this) // 80\r\n}, 80);\r\n```\r\n\r\n### Filter Method {#Filter-Method}\r\n\r\nThe filter() method takes in a callback function and calls that function for every item it iterates over inside the target array. It entails filtering out one or more items (a subset) from a larger collection of items (a superset) based on some condition/preference.\r\n\r\n```\r\nSyntax:\r\narr.filter(function(element, index, array){  }, this);\r\nThe this argument will be used inside the callback function. By default, its value is undefined .\r\n```\r\n\r\n- Example: Filter items out of an array\r\n\r\n```\r\nlet people = [\r\n    {name: \"aaron\",age: 65},\r\n    {name: \"beth\",age: 2},\r\n    {name: \"cara\",age: 13},\r\n    {name: \"daniel\",age: 3},\r\n    {name: \"ella\",age: 25},\r\n    {name: \"fin\",age: 1},\r\n    {name: \"george\",age: 43},\r\n]\r\n\r\nlet toddlers = people.filter(person => person.age <= 3)\r\n\r\nconsole.log(toddlers)\r\n\r\n/*\r\n[{\r\n  age: 2,\r\n  name: \"beth\"\r\n}, {\r\n  age: 3,\r\n  name: \"daniel\"\r\n}, {\r\n  age: 1,\r\n  name: \"fin\"\r\n}]\r\n*/\r\n```\r\n\r\n- Example: How to access the context object with this\r\n\r\n```\r\nlet people = [\r\n    {name: \"aaron\", age: 65},\r\n    {name: \"beth\", age: 15},\r\n    {name: \"cara\", age: 13},\r\n    {name: \"daniel\", age: 3},\r\n    {name: \"ella\", age: 25},\r\n    {name: \"fin\", age: 16},\r\n    {name: \"george\", age: 18},\r\n]\r\n\r\nlet range = {\r\n  lower: 13,\r\n  upper: 16\r\n}\r\n\r\n\r\nlet teenagers = people.filter(function(person) {\r\n\treturn person.age >= this.lower && person.age <= this.upper;\r\n}, range)\r\n\r\nconsole.log(teenagers)\r\n\r\n/*\r\n[{\r\n  age: 15,\r\n  name: \"beth\"\r\n}, {\r\n  age: 13,\r\n  name: \"cara\"\r\n}, {\r\n  age: 16,\r\n  name: \"fin\"\r\n}]\r\n*/\r\n```\r\n\r\n### Reduce Method {#Reduce-Method}\r\n\r\n```\r\nSyntax\r\narray.reduce(function(total, currentValue, currentIndex, arr), initialValue)\r\n```\r\n\r\nArray.reduce takes two parameters.\r\n\r\n- The reducer\r\n- An initial value (optional)\r\n\r\n- The reducer is the function doing all the work. As reduce loops over your list, it feeds two parameters to your reducer.\r\n\r\n- An accumulator\r\n\r\nAccumulator is the eventual return value\r\nWhen you're looping through the users, how are you keeping track of their total age? You need some counter variable to hold it. That's the accumulator\r\n\r\n- The current value\r\n\r\nThe current value is just like when you use array[i] in a regular loop.\r\n\r\n- Example:\r\n\r\n```\r\nvar euros = [29.76, 41.85, 46.5];\r\n\r\nvar sum = euros.reduce( function(total, amount){\r\n  return total + amount\r\n}, 0);\r\n\r\nsum // 118.11\r\n```\r\n\r\n## Using call(), apply() and bind() {#Using-call-apply-and-bind}\r\n\r\nWe can have objects that have their own properties and methods.\r\nBut object1 cannot use the methods of object2 and vice versa.\r\n\r\n![CAB](/BL-1007/cab.png)\r\n\r\nWe can use call(), apply(), and bind() methods to tie a function into an object and call the function as if it belonged to that object.\r\n\r\n### Call() Method in JavaScript {#Call-Method-in-JavaScript}\r\n\r\nThe call() method invokes a function with a specified context.\r\n\r\n```\r\nvar obj = { firstName: \"a\", lastName:\"b\" };\r\n\r\nfunction fullName(){\r\n  return this.firstName + this.lastName;\r\n}\r\n```\r\n\r\nuse the call() method to tie the function add() to the object obj:\r\n\r\n```\r\nadd.call(obj, 3);\r\n```\r\n\r\n**Use Call() with Multiple Arguments**\r\n\r\n```\r\nfunction fullName(a, b){\r\n  return this.firstName + this.lastName + a + b;\r\n}\r\n\r\nconsole.log(add.call(obj, \"x\", \"y\"));\r\n```\r\n\r\n### Apply() Method in JavaScript {#Apply-Method-in-JavaScript}\r\n\r\nThe apply() method does the exact same as call(). The difference is that call() accepts an argument list, but apply() accepts an array of arguments.\r\n\r\n```\r\nvar obj = { firstName: \"a\", lastName:\"b\" };\r\n\r\nfunction fullName(){\r\n  return this.firstName + this.lastName;\r\n}\r\n\r\nconsole.log(add.apply(obj, [\"x\", \"y\"]));\r\n```\r\n\r\n### Bind() Method in JavaScript {#Bind-Method-in-JavaScript}\r\n\r\ncall() and apply() methods are executed immediately when called (and returned a value).\r\nBut instead of executing a function immediately, bind() returns a copy of a function that can be executed later on.\r\n\r\n```\r\nvar obj = { num: 2 };\r\n\r\nfunction add(a, b){\r\n  return this.num + a + b;\r\n}\r\n\r\nconst func = add.bind(obj, 3, 5);\r\nfunc(); // Returns 10\r\n```\r\n\r\n## Async and Defer {#Async-and-Defer}\r\n\r\n- Without using async and defer\r\n  The parsing is paused until the script is fetched, and executed. Once this is done, parsing resumes.\r\n\r\n![Async-Defer](/BL-1007/without-defer-async-head.png)\r\n\r\n- Page loading a script with async\r\n  The script is fetched asynchronously, and when it’s ready the HTML parsing is paused to execute the script, then it’s resumed.\r\n\r\n![Async](/BL-1007/with-async.png)\r\n\r\n- Page loading With defer\r\n  The script is fetched asynchronously, and it’s executed only after the HTML parsing is done.\r\n\r\n![Defer](/BL-1007/with-defer.png)\r\n\r\n## Event Throtting and debouncing {#Event-Throtting-and-debouncing}\r\n\r\nDebouncing and Throttling techniques enhance the performance of your website, also prevent unnecessary API calls and load on the server.\r\n\r\nDebouncing and throttling techniques are used to limit the number of times a function can execute.\r\n\r\n### Throttling {#Throttling}\r\n\r\nThrottling is a technique in which, no matter how many times the user fires the event, the attached function will be executed only once in a given time interval.\r\n\r\n**Example**\r\n\r\n```\r\nlet timer;\r\n\r\nconst handleInput = (val, delay) => {\r\n  if (timer) {\r\n    return;\r\n  }\r\n\r\n  timer = setTimeout(() => {\r\n    console.log(val);\r\n    timer = undefined;\r\n  }, delay);\r\n};\r\n\r\ndocument.getElementById(\"search-box\").addEventListener(\"keypress\", (e) => {\r\n  handleInput(e.target.value, 1000);\r\n});\r\n```\r\n\r\n### Debouncing {#Debouncing}\r\n\r\nIn the debouncing technique, no matter how many times the user fires the event, the attached function will be executed only after the specified time once the user stops firing the event.\r\n\r\n**Example**\r\n\r\n```\r\nlet timer;\r\n\r\nconst handleInput = (val, delay) => {\r\n  clearTimeout(timer);\r\n\r\n  timer = setTimeout(() => {\r\n    console.log(val);\r\n  }, delay);\r\n};\r\n\r\ndocument.getElementById(\"search-box\").addEventListener(\"keypress\", (e) => {\r\n  handleInput(e.target.value, 1000);\r\n});\r\n```\r\n\r\n## Event Bubbling and Capturing {#Event-Bubbling-and-Capturing}\r\n\r\n![eventflow](/BL-1007/eventflow.svg)\r\n\r\n### Event Bubbling {#Event-Bubbling}\r\n\r\n**When an event happens on an element, it first runs the handlers on it, then on its parent, then all the way up on other ancestors.**\r\n\r\n```\r\nLet’s say we have 3 nested elements FORM > DIV > P with a handler on each of them\r\n\r\n<form onclick=\"alert('form')\">FORM\r\n  <div onclick=\"alert('div')\">DIV\r\n    <p onclick=\"alert('p')\">P</p>\r\n  </div>\r\n</form>\r\n\r\nA click on the inner <p> first runs onclick:\r\n\r\nOn that <p>.\r\nThen on the outer <div>.\r\nThen on the outer <form>.\r\nAnd so on upwards till the document object.\r\n```\r\n\r\n![event-order-bubbling](/BL-1007/event-order-bubbling.svg)\r\n\r\n### Event Capturing {#Event-Capturing}\r\n\r\n**In event capturing, an event propagates from the outermost element to the target element.**\r\n\r\n![event-order-capture](/BL-1007/capture.svg)\r\n\r\n```\r\nClicking on the p element calls the click event handlers of all parent elements, starting from the outer and propagating inside to the target element p:\r\nhtml → body → article → div → p.\r\n```\r\n\r\n### Stopping bubbling {#Stopping-bubbling}\r\n\r\n```\r\nevent.stopPropagation()\r\n```\r\n\r\nevent.stopPropagation() stops the move upwards, but on the current element all other handlers will run.\r\n","readTime":{"text":"11 min read","minutes":10.69,"time":641400,"words":2138}},{"data":{"Id":1008,"Title":"Javascript Event Loop - Explained","Author":"Soumyajit","Tags":"Javascript Interview","Topic":"Javascript","Abstract":"Understanding how javascript works under the hood, how it executes our asynchronous javascript code and event loop","HeaderImage":"/BL-1008/header.png","isPublished":true},"content":"\r\nBrowser JavaScript execution flow, as well as in Node.js, is based on an event loop. `The event loop concept is very simple. There’s an endless loop, where the JavaScript engine waits for tasks, executes them, and then sleeps, waiting for more tasks.`\r\n\r\n`The event loop is the secret behind JavaScript’s asynchronous programming.`\r\n\r\n## Event Loop Visualisation/Basic Architecture {#Event-Loop-VisualisationBasic-Architecture}\r\n\r\n![Event Loop](/BL-1008/eventloop.png)\r\n\r\n### Memory Heap {#Memory-Heap}\r\n\r\nThis is where all the memory allocation happens for your variables, that you have defined in your program.\r\n\r\n### Call Stack {#Call-Stack}\r\n\r\nThis represents the single thread provided for JavaScript code execution. This is where all your javascript code gets pushed and executed one by one as the interpreter reads your program, and gets popped out once the execution is done. It is responsible for keeping track of all the operations in line to be executed. Whenever a function is finished, it is popped from the stack.\r\n\r\n### Browser or Web APIs {#Browser-or-Web-APIs}\r\n\r\nThey are built into your web browser and are able to expose data from the browser and surrounding computer environment and do useful complex things with it. They are not part of the JavaScript language itself, rather they are built on top of the core JavaScript language, providing you with extra superpowers to use in your JavaScript code.\r\n\r\nFor example, the Geolocation API provides some simple JavaScript constructs for retrieving location data so you can say, plot your location on a Google Map. In the background, the browser is actually using some complex lower-level code (e.g. C++) to communicate with the device’s GPS hardware (or whatever is available to determine position data), retrieve position data, and return it to the browser environment to use in your code. But again, this complexity is abstracted away from you by the API.\r\n\r\n**Common browser APIs**\r\n\r\n- APIs for manipulating documents\r\n- APIs that fetch data from the server\r\n- Audio and Video APIs\r\n- Client-side storage APIs\r\n\r\n### Event or Callback Queue {#Event-or-Callback-Queue}\r\n\r\nThis is where your asynchronous code gets pushed to, and waits for the execution.\r\n\r\n### Event Loop {#Event-Loop}\r\n\r\nIt has one simple job `to monitor the call stack and the callback queue.`\r\nIt keeps running continuously and checks the Main stack, if it has any frames to execute, if not then it checks Callback queue, if Callback queue has codes to execute then it pops the message from it to the Main Stack for the execution.\r\n\r\n### Job Queue or Microtask Queue {#Job-Queue-or-Microtask-Queue}\r\n\r\nApart from Callback Queue, browsers have introduced one more queue which is “Job Queue”, reserved only for new Promise() functionality. So when you use promises in your code, you add .then() method, which is a callback method. These `thenable` methods are added to Job Queue once the promise has returned/resolved, and then gets executed.\r\n\r\n## Execution of async function in javascript {#Execution-of-async-function-in-javascript}\r\n\r\nWhenever an async function is called, it is sent to a browser API. These are APIs built into the browser.\r\n\r\n`An example of this is the setTimeout method. When a setTimeout operation is processed, it is sent to the corresponding API which waits till the specified time to send this operation back in for processing.`\r\n\r\n`This operation is then send to the callback queue. Hence, we have a cyclic system for running async operations in JavaScript. The language itself is single-threaded, but the browser APIs act as separate threads.`\r\n\r\nThe `event loop` facilitates this process. It has one simple job `to monitor the call stack and the callback queue.` If the call stack is empty, the event loop will take the first event from the queue and will push it to the call stack, which effectively runs. If it is not, then the current function call is processed.\r\n\r\n```\r\nconst foo = () => console.log(\"First\");\r\nconst bar = () => setTimeout(() => console.log(\"Second\"), 500);\r\nconst baz = () => console.log(\"Third\");\r\n\r\nbar();\r\nfoo();\r\nbaz();\r\n\r\nOutput:\r\nFirst\r\nThird\r\nSecond\r\n```\r\n\r\n![Callback Queue](/BL-1008/callbackqueue.gif)\r\n\r\n## Why Job Queue or Microtask Queue {#Why-Job-Queue-or-Microtask-Queue}\r\n\r\nMicro-tasks has high priority in executing callbacks, if event loop tick comes to Micro-tasks, it will execute all the jobs in job queue first until it gets empty, then will move to callback queue.\r\n\r\n- The primary reason for prioritizing the micro-task queue is to improve the user experience.\r\n- Micro-tasks include mutation observer callbacks as well as promise callbacks.\r\n\r\n![micro-task Queue](/BL-1008/microtask.gif)\r\n\r\nExample:\r\n\r\n```\r\nconsole.log('Message no. 1: Sync');\r\n\r\nsetTimeout(function() {\r\n   console.log('Message no. 2: setTimeout');\r\n}, 0);\r\n\r\nvar promise = new Promise(function(resolve, reject) {\r\n   resolve();\r\n});\r\n\r\npromise.then(function(resolve) {\r\n   console.log('Message no. 3: 1st Promise');\r\n})\r\n.then(function(resolve) {\r\n   console.log('Message no. 4: 2nd Promise');\r\n});\r\n\r\nconsole.log('Message no. 5: Sync');\r\n\r\n// Message no. 1: Sync\r\n// Message no. 5: Sync\r\n// Message no. 3: 1st Promise\r\n// Message no. 4: 2nd Promise\r\n// Message no. 2: setTimeout\r\n```\r\n\r\nAll `thenable` callbacks of the promise are called first, then the setTimeout callback is called.\r\n\r\n**References:**\r\n\r\n- <a href=\"https://towardsdev.com/event-loop-in-javascript-672c07618dc9\" target=\"_blank\">Event Loop</a>\r\n","readTime":{"text":"5 min read","minutes":4.07,"time":244200,"words":814}},{"data":{"Id":1009,"Title":"Prototype and Prototypical Inheritance","Author":"Soumyajit","Tags":"Javascript Interview","Topic":"Javascript","Abstract":"Understanding And Using Prototype and Prototypical Inheritance in JavaScript","HeaderImage":"/BL-1009/header.jpg","isPublished":true},"content":"\r\n## Prototype {#Prototype}\r\n\r\n![Prototype](/BL-1009/object-prototype-empty.svg)\r\n\r\n**The prototype is an object that is associated with every functions and objects by default in JavaScript.**\r\n\r\nWhenever we create a function , object or array javacript by default attaches a prototype object to it which contains some additional methods inside it.\r\n\r\n![Prototype](/BL-1009/proto.png)\r\nAll JavaScript objects inherit properties and methods from a prototype:\r\n\r\n- Date objects inherit from Date.prototype.\r\n- Array objects inherit from Array.prototype.\r\n- Player objects inherit from Player.prototype.\r\n\r\n- The Object.prototype is on top of the prototype inheritance chain. Date objects, Array objects, and Player objects all inherit from Object.prototype.\r\n\r\n## The Prototype Chain {#The-Prototype-Chain}\r\n\r\nPrototypal inheritance uses the concept of prototype chaining.\r\n\r\nEvery object created contains [[Prototype]], which points either to another object or null.\r\n\r\nExample:-\r\nAn object C with a [[Prototype]] property that points to object B. Object B’s [[Prototype]] property points to prototype object A. This continues onward, forming a kind of chain called the prototype chain.\r\n\r\n## Prototypal Inheritance {#Prototypal-Inheritance}\r\n\r\n```\r\nlet animal = {\r\n  eats: true\r\n   walk() {\r\n    console.log(\"Animal walk\");\r\n  }\r\n};\r\n\r\nlet rabbit = {\r\n  jumps: true\r\n  __proto__ = animal;\r\n};\r\n\r\n\r\n// we can find both properties in rabbit now:\r\nconsole.log(rabbit.eats ); // true\r\n\r\nrabbit.walk(); // Animal walk\r\n\r\n```\r\n\r\n![Prototype](/BL-1009/rabbit-animal-object.svg)\r\n\r\n```\r\nconst obj = {\r\n  firstName: \"sds\",\r\n  lastName: \"bh\",\r\n  getFullName: function () {\r\n    return this.firstName + \" \" + this.lastName;\r\n  }\r\n};\r\n\r\nconst obj2 = {\r\n  firstName: \"ab\",\r\n  __proto__: obj\r\n};\r\n\r\nconsole.log(obj2.getFullName()); //ab bh\r\n```\r\n\r\n## Creating own prototype {#Creating-own-prototype}\r\n\r\nCreating Ployfill for bind method\r\n\r\n```\r\nconst obj = {\r\n  firstName: \"sds\",\r\n  lastName: \"bh\"\r\n};\r\n\r\nfunction getFullName(state) {\r\n  return this.firstName + \" \" + this.lastName + \" \" + state;\r\n}\r\n\r\nconst fName = getFullName.bind(obj, \"rnc\");\r\nconsole.log(fName()); //sds bh rnc\r\n\r\nFunction.prototype.myBind = function (...args) {\r\n  const func = this;\r\n  const params = args.slice(1);\r\n  return function () {\r\n    return func.apply(args[0], params);\r\n  };\r\n};\r\n\r\nconst fName2 = getFullName.myBind(obj, \"bsh\");\r\nconsole.log(fName2()); //sds bh bsh\r\n```\r\n\r\n## Creating Ployfill for Call, Apply and Bind method {#Creating-Ployfill-for-Call-Apply-and-Bind-method}\r\n\r\n```\r\nconst obj = {\r\n  firstName: \"sds\",\r\n  lastName: \"bh\"\r\n};\r\n\r\nfunction getFullName(state) {\r\n  return this.firstName + \" \" + this.lastName + \" \" + state;\r\n}\r\n\r\nFunction.prototype.myBind = function (obj, ...args) {\r\n  obj.func = this;\r\n  return () => {\r\n    return obj.func(...args);\r\n  };\r\n};\r\n\r\nFunction.prototype.myCall = function (obj, ...args) {\r\n  obj.func = this;\r\n  return obj.func(...args);\r\n};\r\n\r\nFunction.prototype.myApply = function (obj, args) {\r\n  obj.func = this;\r\n  return obj.func(...args);\r\n};\r\n\r\nconst fName2 = getFullName.myBind(obj, \"bsh\");\r\nconsole.log(fName2()); //sds bh bsh\r\n\r\nconsole.log(getFullName.myCall(obj, \"kkr\"));  //sds bh kkr\r\n\r\nconsole.log(getFullName.myApply(obj, [\"kkr\"]));  //sds bh kkr\r\n```\r\n","readTime":{"text":"3 min read","minutes":2.06,"time":123600,"words":412}},{"data":{"Id":1010,"Title":"React Lifecycle Methods","Author":"Soumyajit","Tags":"React Interview","Topic":"React","Abstract":"Lifecycle methods are series of events that happen throughout the birth, growth, and death of a React component.","HeaderImage":"/BL-1010/Header.jpg","isPublished":true},"content":"\r\n**Visual overview of topics covered in this tutorial**\r\n\r\n![Lifecycle](/BL-1010/Lifecycle.png)\r\n\r\n## What is the React component lifecycle? {#What-is-the-React-component-lifecycle}\r\n\r\nIn React, components go through a lifecycle of events:\r\n\r\n- Mounting (adding nodes to the DOM)\r\n- Updating (altering existing nodes in the DOM)\r\n- Unmounting (removing nodes from the DOM)\r\n\r\n## Mounting lifecycle methods {#Mounting-lifecycle-methods}\r\n\r\nThe mounting phase refers to the phase during which a component is created and inserted to the DOM.\r\nThe following methods are called in order.\r\n\r\n- constructor()\r\n- static getDerivedStateFromProps()\r\n- render()\r\n- componentDidMount()\r\n\r\n### constructor() {#constructor}\r\n\r\nThe constructor() is the very first method that is invoked before the component is mounted to the DOM.\r\n\r\nThe constructor method is called before the component is mounted to the DOM. In most cases, you would initialize state and bind event handlers methods within the constructor method.\r\n\r\nExample of the constructor() React lifecycle method in action:\r\n\r\n```\r\nconst MyComponent extends React.Component {\r\n  constructor(props) {\r\n   super(props)\r\n    this.state = {\r\n       points: 0\r\n    }\r\n    this.handlePoints = this.handlePoints.bind(this)\r\n    }\r\n}\r\n```\r\n\r\n### static getDerivedStateFromProps() {#static-getDerivedStateFromProps}\r\n\r\nIts main function is to ensure that the state and props are in sync for when it’s required.\r\n\r\nThe basic structure of the static getDerivedStateFromProps() looks like this:\r\n\r\n```\r\nstatic getDerivedStateFromProps(props, state) {\r\n  //do stuff here\r\n}\r\n```\r\n\r\n```\r\nYou can return an object to update the state of the component:\r\n\r\nstatic getDerivedStateFromProps(props, state) {\r\n    return {\r\n       points: 200 // update state with this\r\n    }\r\n}\r\n\r\nOr you can return null to make no updates:\r\n\r\nstatic getDerivedStateFromProps(props, state) {\r\n return null\r\n}\r\n```\r\n\r\n```\r\nclass App extends Component {\r\n  state = {\r\n    points: 10\r\n  }\r\n\r\n  // *******\r\n  //  NB: Not the recommended way to use this method. Just an example. Unconditionally overriding state here is generally considered a bad idea\r\n  // ********\r\n\r\n  static getDerivedStateFromProps(props, state) {\r\n    return {\r\n      points: 1000\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"App\">\r\n        <header className=\"App-header\">\r\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\r\n          <p>\r\n            You've scored {this.state.points} points.\r\n          </p>\r\n        </header>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nThe 1000 comes from updating state within the static getDerivedStateFromProps method.\r\n\r\n```\r\n\r\n### render() {#render}\r\n\r\nAs the name suggests it handles the rendering of your component to the UI\r\n\r\n```\r\nclass Hello extends Component{\r\n   render(){\r\n      return <div>Hello {this.props.name}</div>\r\n   }\r\n}\r\n```\r\n\r\nThe render() method returns JSX that is displayed in the UI. A render() can also return a null if there is nothing to render for that component.\r\n\r\nA render() method has to be pure with no side-effects.\r\nReact requires that your render() is pure. Pure functions are those that do not have any side-effects and will always return the same output when the same inputs are passed. This means that you can not `setState() within a render()`. `You cannot modify the component state within the render().`\r\n\r\n### componentDidMount {#componentDidMount}\r\n\r\nAfter render is called, `the component is mounted to the DOM and the componentDidMount method is invoked.`\r\n\r\nThis function is invoked immediately after the component is mounted to the DOM.\r\n\r\nYou would use the componentDidMount lifecycle method to grab a DOM node from the component tree immediately after it’s mounted.\r\n\r\n**If you also want to make network requests as soon as the component is mounted to the DOM, this is a perfect place to do so.**\r\n\r\n```\r\ncomponentDidMount() {\r\n  this.fetchListOfTweets() // where fetchListOfTweets initiates a netowrk request to fetch a certain list of tweets.\r\n}\r\n```\r\n\r\n**You could also set up subscriptions such as timers**\r\n\r\n```\r\n// e.g requestAnimationFrame\r\ncomponentDidMount() {\r\n    window.requestAnimationFrame(this._updateCountdown);\r\n }\r\n```\r\n\r\n## Updating lifecycle methods {#Updating-lifecycle-methods}\r\n\r\nWhenever a change is made to the state or props of a React component, the component is rerendered. In simple terms, the component is updated. This is the updating phase of the React component lifecycle.\r\n\r\n- shouldComponentUpdate()\r\n- render()\r\n- getSnapshotBeforeUpdate()\r\n- componentDidUpdate()\r\n\r\n### shouldComponentUpdate() {#shouldComponentUpdate}\r\n\r\nIn most cases, you’ll want a component to rerender when state or props changes. However, you do have control over this behavior.\r\n\r\nWithin this lifecycle method, you can return a boolean true or false and control whether the component gets rerendered (e.g., upon a change in state or props).\r\n\r\n```\r\nshouldComponentUpdate(nextProps, nextState)\r\n{\r\n return this.props.title !== nextProps.title ||\r\n  this.state.input !== nextState.input\r\n}\r\n```\r\n\r\n### render() {#render}\r\n\r\nAfter the shouldComponentUpdate method is called, render is called immediately afterward, depending on the returned value from shouldComponentUpdate, which defaults to true.\r\n\r\n### getSnapshotBeforeUpdate() {#getSnapshotBeforeUpdate}\r\n\r\nThe getSnapshotBeforeUpdatelifecycle method stores the previous values of the state after the DOM is updated. getSnapshotBeforeUpdate() is called right after the render method.\r\n\r\n```\r\ngetSnapshotBeforeUpdate(prevProps, prevState) {\r\n\r\n}\r\n```\r\n\r\nHere’s the important thing: the value queried from the DOM in getSnapshotBeforeUpdate refers to the `value just before the DOM is updated, even though the render method was previously called`.\r\n\r\n`The getSnapshotBeforeUpdate React lifecycle method doesn’t work on its own. It is meant to be used in conjunction with the componentDidUpdate lifecycle method`.\r\n\r\n### componentDidUpdate() {#componentDidUpdate}\r\n\r\nThe componentDidUpdate lifecycle method is invoked after the getSnapshotBeforeUpdate. As with the getSnapshotBeforeUpdate method it receives the previous props and state as arguments:\r\n\r\n```\r\ncomponentDidUpdate(prevProps, prevState) {\r\n\r\n}\r\n```\r\n\r\nHowever it also takes whatever value is returned from the getSnapshotBeforeUpdate lifecycle method is passed as the third argument to the componentDidUpdate method.\r\n\r\n```\r\ncomponentDidUpdate(prevProps, prevState, snapshot) {\r\n\r\n}\r\n```\r\n\r\n## Unmounting lifecycle method {#Unmounting-lifecycle-method}\r\n\r\nThe following method is invoked during the component unmounting phase\r\n\r\n- componentWillUnmount()\r\n\r\n### componentWillUnmount() {#componentWillUnmount}\r\n\r\nThe componentWillUnmount lifecycle method is invoked immediately before a component is unmounted and destroyed. This is the ideal place to perform any necessary cleanup such as clearing up timers, cancelling network requests, or cleaning up any subscriptions that were created in componentDidMount().\r\n\r\n```\r\n// e.g add event listener\r\ncomponentDidMount() {\r\n  el.addEventListener()\r\n}\r\n```\r\n\r\n```\r\n// e.g remove event listener\r\ncomponentWillUnmount() {\r\n  el.removeEventListener()\r\n}\r\n```\r\n\r\n**References:**\r\n\r\n- <a href=\"https://programmingwithmosh.com/javascript/react-lifecycle-methods\" target=\"_blank\">React Lifecycle Methods- A Deep Dive</a>\r\n- <a href=\"https://blog.logrocket.com/react-lifecycle-methods-tutorial-examples\" target=\"_blank\">React lifecycle methods: An approachable tutorial with examples</a>\r\n","readTime":{"text":"5 min read","minutes":4.81,"time":288600,"words":962}}],"topics":["Git","React","Javascript"]},"__N_SSG":true}