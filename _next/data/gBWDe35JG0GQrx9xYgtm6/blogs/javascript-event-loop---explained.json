{"pageProps":{"data":{"Id":1008,"Title":"Javascript Event Loop - Explained","Author":"Soumyajit","Tags":"Javascript Interview","Topic":"Javascript","Abstract":"Understanding how javascript works under the hood, how it executes our asynchronous javascript code and event loop","HeaderImage":"/BL-1008/header.png","isPublished":true},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\",\n    h2: \"h2\",\n    img: \"img\",\n    h3: \"h3\",\n    strong: \"strong\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"Browser JavaScript execution flow, as well as in Node.js, is based on an event loop. \", _jsx(_components.code, {\n        children: \"The event loop concept is very simple. There’s an endless loop, where the JavaScript engine waits for tasks, executes them, and then sleeps, waiting for more tasks.\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"The event loop is the secret behind JavaScript’s asynchronous programming.\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"Event-Loop-VisualisationBasic-Architecture\",\n      children: \"Event Loop Visualisation/Basic Architecture\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/BL-1008/eventloop.png\",\n        alt: \"Event Loop\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"Memory-Heap\",\n      children: \"Memory Heap\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This is where all the memory allocation happens for your variables, that you have defined in your program.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"Call-Stack\",\n      children: \"Call Stack\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This represents the single thread provided for JavaScript code execution. This is where all your javascript code gets pushed and executed one by one as the interpreter reads your program, and gets popped out once the execution is done. It is responsible for keeping track of all the operations in line to be executed. Whenever a function is finished, it is popped from the stack.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"Browser-or-Web-APIs\",\n      children: \"Browser or Web APIs\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"They are built into your web browser and are able to expose data from the browser and surrounding computer environment and do useful complex things with it. They are not part of the JavaScript language itself, rather they are built on top of the core JavaScript language, providing you with extra superpowers to use in your JavaScript code.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For example, the Geolocation API provides some simple JavaScript constructs for retrieving location data so you can say, plot your location on a Google Map. In the background, the browser is actually using some complex lower-level code (e.g. C++) to communicate with the device’s GPS hardware (or whatever is available to determine position data), retrieve position data, and return it to the browser environment to use in your code. But again, this complexity is abstracted away from you by the API.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Common browser APIs\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"APIs for manipulating documents\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"APIs that fetch data from the server\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Audio and Video APIs\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Client-side storage APIs\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"Event-or-Callback-Queue\",\n      children: \"Event or Callback Queue\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This is where your asynchronous code gets pushed to, and waits for the execution.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"Event-Loop\",\n      children: \"Event Loop\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It has one simple job \", _jsx(_components.code, {\n        children: \"to monitor the call stack and the callback queue.\"\n      }), \"\\nIt keeps running continuously and checks the Main stack, if it has any frames to execute, if not then it checks Callback queue, if Callback queue has codes to execute then it pops the message from it to the Main Stack for the execution.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"Job-Queue-or-Microtask-Queue\",\n      children: \"Job Queue or Microtask Queue\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Apart from Callback Queue, browsers have introduced one more queue which is “Job Queue”, reserved only for new Promise() functionality. So when you use promises in your code, you add .then() method, which is a callback method. These \", _jsx(_components.code, {\n        children: \"thenable\"\n      }), \" methods are added to Job Queue once the promise has returned/resolved, and then gets executed.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"Execution-of-async-function-in-javascript\",\n      children: \"Execution of async function in javascript\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Whenever an async function is called, it is sent to a browser API. These are APIs built into the browser.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"An example of this is the setTimeout method. When a setTimeout operation is processed, it is sent to the corresponding API which waits till the specified time to send this operation back in for processing.\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"This operation is then send to the callback queue. Hence, we have a cyclic system for running async operations in JavaScript. The language itself is single-threaded, but the browser APIs act as separate threads.\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"event loop\"\n      }), \" facilitates this process. It has one simple job \", _jsx(_components.code, {\n        children: \"to monitor the call stack and the callback queue.\"\n      }), \" If the call stack is empty, the event loop will take the first event from the queue and will push it to the call stack, which effectively runs. If it is not, then the current function call is processed.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"const foo = () => console.log(\\\"First\\\");\\nconst bar = () => setTimeout(() => console.log(\\\"Second\\\"), 500);\\nconst baz = () => console.log(\\\"Third\\\");\\n\\nbar();\\nfoo();\\nbaz();\\n\\nOutput:\\nFirst\\nThird\\nSecond\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/BL-1008/callbackqueue.gif\",\n        alt: \"Callback Queue\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"Why-Job-Queue-or-Microtask-Queue\",\n      children: \"Why Job Queue or Microtask Queue\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Micro-tasks has high priority in executing callbacks, if event loop tick comes to Micro-tasks, it will execute all the jobs in job queue first until it gets empty, then will move to callback queue.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"The primary reason for prioritizing the micro-task queue is to improve the user experience.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Micro-tasks include mutation observer callbacks as well as promise callbacks.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/BL-1008/microtask.gif\",\n        alt: \"micro-task Queue\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Example:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"console.log('Message no. 1: Sync');\\n\\nsetTimeout(function() {\\n   console.log('Message no. 2: setTimeout');\\n}, 0);\\n\\nvar promise = new Promise(function(resolve, reject) {\\n   resolve();\\n});\\n\\npromise.then(function(resolve) {\\n   console.log('Message no. 3: 1st Promise');\\n})\\n.then(function(resolve) {\\n   console.log('Message no. 4: 2nd Promise');\\n});\\n\\nconsole.log('Message no. 5: Sync');\\n\\n// Message no. 1: Sync\\n// Message no. 5: Sync\\n// Message no. 3: 1st Promise\\n// Message no. 4: 2nd Promise\\n// Message no. 2: setTimeout\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"All \", _jsx(_components.code, {\n        children: \"thenable\"\n      }), \" callbacks of the promise are called first, then the setTimeout callback is called.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"References:\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(\"a\", {\n          href: \"https://towardsdev.com/event-loop-in-javascript-672c07618dc9\",\n          target: \"_blank\",\n          children: \"Event Loop\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"Id":1008,"Title":"Javascript Event Loop - Explained","Author":"Soumyajit","Tags":"Javascript Interview","Topic":"Javascript","Abstract":"Understanding how javascript works under the hood, how it executes our asynchronous javascript code and event loop","HeaderImage":"/BL-1008/header.png","isPublished":true}},"id":"javascript-event-loop---explained","headings":[{"text":"Event Loop Visualisation/Basic Architecture","level":2,"id":"Event-Loop-VisualisationBasic-Architecture","uid":1001},{"text":"Memory Heap","level":3,"id":"Memory-Heap","uid":1002},{"text":"Call Stack","level":3,"id":"Call-Stack","uid":1003},{"text":"Browser or Web APIs","level":3,"id":"Browser-or-Web-APIs","uid":1004},{"text":"Event or Callback Queue","level":3,"id":"Event-or-Callback-Queue","uid":1005},{"text":"Event Loop","level":3,"id":"Event-Loop","uid":1006},{"text":"Job Queue or Microtask Queue","level":3,"id":"Job-Queue-or-Microtask-Queue","uid":1007},{"text":"Execution of async function in javascript","level":2,"id":"Execution-of-async-function-in-javascript","uid":1008},{"text":"Why Job Queue or Microtask Queue","level":2,"id":"Why-Job-Queue-or-Microtask-Queue","uid":1009}],"topics":["Git","React","Javascript"]},"__N_SSG":true}