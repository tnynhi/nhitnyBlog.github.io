{"pageProps":{"blogs":[{"data":{"Id":1004,"Title":"Rough","Author":"Soumyajit","Tags":"Interview Javascript","Topic":"Javascript","Abstract":"Learning some of the fundamental concepts of Javascript and top questions asked in javascript interview.","HeaderImage":"/BL-1001/header.jpg","isPublished":false},"content":"\n## Global vs Local Scope {#Global-vs-Local-Scope}\n\n## Async Defer\n\n## Event bubbling capturing\n\n## Event Throtting and debouncing\n","readTime":{"text":"1 min read","minutes":0.09,"time":5400,"words":18}},{"data":{"Id":1005,"Title":"Understanding Promises in Javasript","Author":"Soumyajit","Tags":"Javascript Interview","Topic":"Javascript","Abstract":"Learning about Promises in Javascript","HeaderImage":"/BL-1005/header.png","isPublished":true},"content":"\n## What is a Promise in JavaScript {#What-is-a-Promise-in-JavaScript}\n\nA Promise is a special JavaScript object. It produces a value after an asynchronous operation completes successfully, or an error if it does not complete successfully due to time out, network error, and so on.\n\n## Creating a JavaScript Promise {#Creating-a-JavaScript-Promise}\n\nWhen the task completes, you either fulfill your promise or fail to do so.\nPromise is a constructor function, so you need to use the `new keyword` to create one. It takes a function, as its argument, with two parameters - `resolve and reject`. These are methods used to determine the outcome of the promise.\n\n```\nCreating a Promise\n\nconst myPromise = new Promise((resolve, reject) => {\n});\n```\n\n## Promise States {#Promise-States}\n\nA promise has three states: `pending, fulfilled, and rejected.` The resolve and reject parameters given to the promise argument are used to do this. resolve is used when you want your promise to succeed, and reject is used when you want it to fail. These are methods that take an argument, as seen below.\n\n- **Pending: Initially when the executor function starts the execution.**\n- **Fulfilled: When the promise is resolved.**\n- **Rejected: When the promise is rejected.**\n\n![Promise States](/BL-1005/states.png)\n\n```\nconst myPromise = new Promise((resolve, reject) => {\n if(condition here) {\n   resolve(\"Promise was fulfilled\");\n } else {\n   reject(\"Promise was rejected\");\n }\n});\n```\n\n## Handling a Promise {#Handling-a-Promise}\n\n![Promise Handling](/BL-1005/handling.png)\n\n### Handling Promises With Then Method {#Handling-Promises-With-Then-Method}\n\nPromises are most useful when you have a process that takes an unknown amount of time in your code (i.e. something asynchronous), often a server request. When you make a server request it takes some amount of time, and after it completes you usually want to do something with the response from the server. This can be achieved by using the then method. The then method is executed immediately after your promise is fulfilled with resolve.\n\n```\nmyPromise.then(result => {\n\n});\n```\n\n### Handling a Rejected Promise with Catch Method {#Handling-a-Rejected-Promise-with-Catch-Method}\n\nCatch is the method used when your promise has been rejected. It is executed immediately after a promise's reject method is called.\n\n```\nmyPromise.catch(error => {\n\n});\n```\n\n## Async Await {#Async-Await}\n\nAsync/await are special syntax to work with promises in a more comfortable fashion.\n\n- **async makes a function return a Promise**\n- **await makes a function wait for a Promise**\n\n### Async {#Async}\n\n```\nExample\nasync function myFunction() {\n  return \"Hello\";\n}\n\nIs the same as:\nasync function myFunction() {\n  return Promise.resolve(\"Hello\");\n}\n```\n\n### Await {#Await}\n\nThe keyword await makes JavaScript wait until that promise settles and returns its result.\nThe `await keyword` can only be used inside an `async` function.\n\n```\nasync function f() {\n\n  let promise = new Promise((resolve, reject) => {\n    setTimeout(() => resolve(\"done!\"), 1000)\n  });\n\n  let result = await promise; // wait until the promise resolves (*)\n\n  alert(result); // \"done!\"\n}\n```\n\nThe function execution \"pauses\" at the line (\\*) and resumes when the promise settles, with result becoming its result.\n\n## Implement Promise {#Implement-Promise}\n\n```\nconst pr1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(\"hello\");\n  }, 4000);\n});\n\nconst pr2 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(\"world\");\n  }, 0);\n});\n\nconst fun = async () => {\n  try {\n    const res = await Promise.all([pr1, pr2]);\n    console.log(res);\n  } catch (err) {\n    console.log(err);\n  }\n};\n\nfun();\n```\n\n**References:**\n\n- <a href=\"https://www.freecodecamp.org/news/javascript-promise-tutorial-how-to-resolve-or-reject-promises-in-js/\" target=\"_blank\">JavaScript Promise Tutorial</a>\n- <a href=\"https://www.w3schools.com/js/js_async.asp\" target=\"_blank\">Async/Await</a>\n","readTime":{"text":"3 min read","minutes":2.85,"time":171000,"words":570}},{"data":{"Id":1006,"Title":"Javascript Concepts - Part1","Author":"Soumyajit","Tags":"Javascript Interview","Topic":"Javascript","Abstract":"Learning some of the fundamental concepts of Javascript and questions asked in javascript interview.","HeaderImage":"/BL-1006/header.png","isPublished":true},"content":"\n## New Features in ES6 {#New-Features-in-ES6}\n\nSome of the new features of javascript introductes in ES6 are:\n\n- The Let keyword\n- The Const keyword\n- Arrow Functions\n- Promises\n- Map Object\n\n```\n// Create a new Map\nconst fruits = new Map();\n\n// Add new Elements to the Map\nfruits.set(apples, 500);\nfruits.set(bananas, 300);\nfruits.set(oranges, 200);\n```\n\n- Set Object\n\n```\n// Create a Set\nconst letters = new Set();\n\n// Add some values to the Set\nletters.add(\"a\");\nletters.add(\"b\");\nletters.add(\"c\");\n```\n\n- Classes\n\n```\nclass ClassName {\n  constructor() { ... }\n}\n\n// Example\nclass Car {\n  constructor(name, year) {\n    this.name = name;\n    this.year = year;\n  }\n}\n```\n\n## Difference between Let and Var and Const {#Difference-between-Let-and-Var-and-Const}\n\n### Comparision of Declarations {#Comparision-of-Declarations}\n\nOne of the biggest problems with declaring variables with the var keyword is that you can easily overwrite variable declarations:\n\n```\nvar camper = \"James\";\nvar camper = \"David\";\nconsole.log(camper);\n```\n\nIn the code above, the camper variable is originally declared as James, and is then overridden to be David. The console then displays the string David.\n\nIf you replace var with let in the code above, it results in an error:\n\n```\nlet camper = \"James\";\nlet camper = \"David\";\nThe error can be seen in your browser console.(Uncaught SyntaxError: Identifier 'camper' has already been declared)\n```\n\n`So unlike var, when you use let, a variable with the same name can only be declared once.`\n\n### Comparision of scopes of the var and let Keywords {#Comparision-of-scopes-of-the-var-and-let-Keywords}\n\nWhen you declare a variable with the var keyword, it is declared globally.\nThe let keyword behaves similarly, but with some extra features. When you declare a variable with the let keyword inside a block, statement, or expression, its scope is limited to that block, statement, or expression.\n\n```\nvar numArray = [];\nfor (var i = 0; i < 3; i++) {\n  numArray.push(i);\n}\nconsole.log(numArray);\nconsole.log(i);\nHere the console will display the values [0, 1, 2] and 3.\n```\n\nWith the var keyword, i is declared globally. So when i++ is executed, it updates the global variable.\n\nThis behavior will cause problems if you were to create a function and store it for later use inside a for loop that uses the i variable. This is because the stored function will always refer to the value of the updated global i variable.\n\n```\nvar printNumTwo;\nfor (var i = 0; i < 3; i++) {\n  if (i === 2) {\n    printNumTwo = function() {\n      return i;\n    };\n  }\n}\nconsole.log(printNumTwo());\nHere the console will display the value 3.\n```\n\nAs you can see, printNumTwo() prints 3 and not 2. This is because the value assigned to i was updated and the printNumTwo() returns the global i and not the value i had when the function was created in the for loop.\n\nThe let keyword does not follow this behavior:\n\n```\nlet printNumTwo;\nfor (let i = 0; i < 3; i++) {\n    if (i === 2) {\n        printNumTwo = function() {\n            return i;\n        };\n    }\n}\nconsole.log(printNumTwo());\nconsole.log(i);\n```\n\nHere the console will display the value 2, and an error that i is not defined. i is not defined because it was not declared in the global scope. It is only declared within the for loop statement. printNumTwo() returned the correct value because three different i variables with unique values (0, 1, and 2) were created by the let keyword within the loop statement.\n\n### Const {#Const}\n\nWhile var and let can be declared without being initialized, const must be initialized during declaration.\n`Const cannot be initialized after declaritions`\n\nHowever, it is important to understand that objects (including arrays and functions) assigned to a variable using const are still mutable. Using the `const declaration only prevents reassignment of the variable identifier.`\n\n```\nconst s = [5, 6, 7];\ns = [1, 2, 3];\ns[2] = 45;\nconsole.log(s);\nThe console.log will display the value [5, 6, 45].\n\ns = [1, 2, 3] will result in an error.\n```\n\nAs you can see, you can mutate the object [5, 6, 7] itself and the variable s will still point to the altered array [5, 6, 45]. Like all arrays, the array elements in s are mutable, but because const was used, you cannot use the variable identifier s to point to a different array using the assignment operator.\n\n## Variable shadowing {#Variable-shadowing}\n\n```\nlet number = 10;\n\nfunction displayDouble() {\n  //new variable is defined with the same name as variable on line 1 - outer scope\n  let number = 3;\n\n  number *= 2;\n  console.log(number); //=> 6\n}\n\ndisplayDouble();\nconsole.log(number); //=> 10\n```\n\nIn this case, both variables on line 1 and 5 are defined with the same name — number.This has a significant result: the variable defined in the outer scope is ‘shadowed’ by the variable defined in the inner scope.\n\n## String in Javascript {#String-in-Javascript}\n\nIn JavaScript, String values are immutable, which means that they cannot be altered once created.\n\nFor example, the following code:\n\nlet myStr = \"Bob\";\nmyStr[0] = \"J\";\ncannot change the value of myStr to Job, because the contents of myStr cannot be altered.\n\n## Escape Sequences in Strings {#Escape-Sequences-in-Strings}\n\n```\nCode   Output\n\\' single quote\n\\\" double quote\n\\\\ backslash\n\\n newline\n\\r carriage return\n\\t tab\n\\b word boundary\n\\f form feed\n```\n\n## Difference between '==' and '===' in javascript {#Difference-between-==-and-===-in-javascript}\n\nStrict equality (===) is the counterpart to the equality operator (==). However, unlike the equality operator, which attempts to convert both values being compared to a common type, the strict equality operator does not perform a type conversion.\n\nIf the values being compared have different types, they are considered unequal, and the strict equality operator will return false.\n\n```\nExamples 1:\n\n3 === 3 //true\n3 === '3' // false\n1 == [1] //true\n1 === [1] //false\nnull == undefined //true\n```\n\n```\nExample 2:‌\nconst number = 1234\nconst stringNumber = '1234'\n\nconsole.log(number == stringNumber) //true\nconsole.log(number === stringNumber)  //false\n```\n\nThe value of number and stringNumber looks similar here. However, the type of number is Number and type of stringNumber is string. Even though the values are same, the type is not the same. Hence a == check returns true, but when checked for value and type, the value is false.\n\n```\nExample 3:\nconsole.log(0 == false) //true\nconsole.log(0 === false) //false\nReason: same value, different type. Type coercion\n```\n\nThis is an interesting case. The value of 0 when checked with false is same. It is so because 0 and false have the same value for JavaScript, but when checked for type and value, the value is false because 0 is a number and false is boolean.\n\n```\nExample 4:\nconst str = \"\"\n\nconsole.log(str == false) //true\nconsole.log(str === false) //false\n```\n\nThe value of empty string and false is same in JavaScript. Hence, == returns true. However, the type is different and hence === returns false.\n\n```\nExample 5:\nlet obj1 = { a: 1, b: 2 };\nlet obj2 = { a: 1, b: 2 };\nconsole.log(obj1 == obj2); //false\nconsole.log(obj1 === obj2); //false\n```\n\nThe important thing to understand here is that the variables, obj1 and obj2 (which could be an Object, Array or Function) each contain only a reference to a location in memory. Not the value of the object.\n\n## Explain how this works in JavaScript {#Explain-how-this-works-in-JavaScript}\n\nTo access a property of an object from within a method of the same object, you need to use the this keyword.\n\n```\nconst person = {\n    name: 'John',\n    age: 30,\n\n    // accessing name property by using this.name\n    greet: function() { console.log('The name is' + ' ' + this.name); }\n};\n\nperson.greet();\n```\n\nIn the above example, a person object is created. It contains properties (name and age) and a method greet.\nIn the method greet, while accessing a property of an object, this keyword is used.\nIn order to access the properties of an object, this keyword is used following by . and key.\n\nThis keyword refers to the `object where it is called.`\n\n### 1 this Inside Global Scope {#1-this-Inside-Global-Scope}\n\nWhen this is used alone, this refers to the global object (window object in browsers). For example,\n\n```\nlet a = this;\nconsole.log(a);  // Window {}\n\nthis.name = 'Sarah';\nconsole.log(window.name); // Sarah\n```\n\n### 2 this Inside Function {#2-this-Inside-Function}\n\nWhen this is used in a function, this refers to the global object (window object in browsers). For example,\n\n```\nfunction greet() {\n    // this inside function\n    // this refers to the global object\n    console.log(this);\n}\ngreet(); // Window {}\n```\n\n### 3 this Inside Constructor Function {#3-this-Inside-Constructor-Function}\n\nIn JavaScript, constructor functions are used to create objects. When a function is used as a constructor function, this refers to the object inside which it is used. For example,\n\n```\nfunction Person() {\n    this.name = 'Jack';\n    console.log(this);\n}\n\nlet person1 = new Person();\nconsole.log(person1.name);\n```\n\nHere, this refers to the person1 object. That's why, person1.name gives us Jack.\nWhen this is used with ES6 classes, it refers to the object inside which it is used.\n\nFor example,\n\n```\n// creating a class\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n}\nThe class keyword is used to create a class. The properties are assigned in a constructor function.\n\n// creating a class\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n// creating an object\nconst person1 = new Person('John');\nconst person2 = new Person('Jack');\n\nconsole.log(person1.name); // John\nconsole.log(person2.name); // Jack\n```\n\n### 4 this Inside Object Method {#4-this-Inside-Object-Method}\n\nWhen this is used inside an object's method, this refers to the object it lies within. For example,\n\n```\nconst person = {\nname : 'Jack',\nage: 25,\n    // this inside method\n    // this refers to the object itself\n    greet() {\n        console.log(this);\n        console.log(this.name);\n    }\n\n}\n\nperson.greet();\nOutput\n{name: \"Jack\", age: 25, greet: ƒ}\nJack\n```\n\n### 5 this Inside Inner Function {#5-this-Inside-Inner-Function}\n\nWhen you access this inside an inner function (inside a method), this refers to the global object. For example,\n\n```\nconst person = {\nname : 'Jack',\nage: 25,\n\n    // this inside method\n    // this refers to the object itself\n    greet() {\n        console.log(this);        // {name: \"Jack\", age ...}\n        console.log(this.age);  // 25\n\n        // inner function\n        function innerFunc() {\n            // this refers to the global object\n            console.log(this);       // Window { ... }\n            console.log(this.age);    // undefined\n        }\n        innerFunc();\n    }\n}\nperson.greet();\n```\n\n### 6 this Inside Arrow Function {#6-this-Inside-Arrow-Function}\n\nInside the arrow function, this refers to the parent scope. For example,\n\n```\nconst greet = () => {\n    console.log(this);\n}\ngreet(); // Window {...}\n```\n\n`Arrow functions do not have their own this`. When you use this inside an arrow function, this refers to its parent scope object.\nFor example,\n\n```\nconst greet = {\n    name: 'Jack',\n\n    // method\n    sayHi () {\n        let hi = () => console.log(this.name);\n        hi();\n    }\n}\ngreet.sayHi(); // Jack\n```\n\n```\nconst person = {\n    name : 'Jack',\n    age: 25,\n\n    // this inside method\n    // this refers to the object itself\n    greet() {\n        console.log(this);\n        console.log(this.age);\n\n        // inner function\n        let innerFunc = () => {\n\n            // this refers to the global object\n            console.log(this);\n            console.log(this.age);\n        }\n        innerFunc();\n    }\n}\n\nperson.greet();\n\nOutput:\n{name: \"Jack\", age: 25, greet: ƒ}\n25\n{name: \"Jack\", age: 25, greet: ƒ}\n25\nHere, innerFunc() is defined using the arrow function. It takes this from its parent scope. Hence, this.age gives 25.\n```\n\n### 7 this Inside Function with Strict Mode {#7-this-Inside-Function-with-Strict-Mode}\n\nWhen this is used in a function with strict mode, this is undefined. For example,\n\n```\n'use strict';\nthis.name = 'Jack';\nfunction greet() {\n\n    // this refers to undefined\n    console.log(this);\n}\ngreet(); // undefined\n```\n\n## How is arrow functions different from normal functions in javascript {#How-is-arrow-functions-different-from-normal-functions-in-javascript}\n\n### this Keyword {#this-Keyword}\n\nInside a `regular function, this keyword refers to the function` where it is called.\n\nHowever, `this is not associated with arrow functions`. `Arrow function does not have its own this`. So whenever you call this, it refers to its parent scope.\n\n**Inside a regular function**\n\n```\nfunction Person() {\n    this.name = 'Jack',\n    this.age = 25,\n    this.sayName = function () {\n\n        // this is accessible\n        console.log(this.age);\n\n        function innerFunc() {\n            // this refers to the global object\n            console.log(this.age);\n            console.log(this);\n        }\n        innerFunc();\n    }\n}\n\nlet x = new Person();\nx.sayName();\n\nOutput:\n25\nundefined\nWindow {}\n```\n\nHere, this.age inside this.sayName() is accessible because this.sayName() is the method of an object.\n\nHowever, innerFunc() is a normal function and this.age is not accessible because this refers to the global object (Window object in the browser). Hence, this.age inside the innerFunc() function gives undefined.\n\n**Inside an arrow function**\n\n```\nfunction Person() {\n    this.name = 'Jack',\n    this.age = 25,\n    this.sayName = function () {\n\n        console.log(this.age);\n        let innerFunc = () => {\n            console.log(this.age);\n        }\n        innerFunc();\n    }\n}\n\nconst x = new Person();\nx.sayName();\n\nOutput\n25\n25\n```\n\nHere, the innerFunc() function is defined using the arrow function. And inside the arrow function, this refers to the parent's scope. Hence, this.age gives 25.\n\n### Arguments Binding {#Arguments-Binding}\n\n`Regular functions have arguments binding`. That's why when you pass arguments to a regular function, you can access them using the arguments keyword.\n\n```\nlet x = function () {\n    console.log(arguments);\n}\nx(4,6,7); // Arguments [4, 6, 7]\n```\n\n`Arrow functions do not have arguments binding`.\nWhen you try to access an argument using the arrow function, it will give an error. For example,\n\n```\nlet x = () => {\n    console.log(arguments);\n}\nx(4,6,7);\n// ReferenceError: Can't find variable: arguments\n```\n\nTo solve this issue, you can use the spread syntax.\n\n```\nlet x = (...n) => {\n  console.log(n);\n}\nx(4,6,7); // [4, 6, 7]\n```\n","readTime":{"text":"12 min read","minutes":11.39,"time":683400,"words":2278}},{"data":{"Id":1007,"Title":"Javascript Concepts - Part2","Author":"Soumyajit","Tags":"Javascript Interview","Topic":"Javascript","Abstract":"Learning some of the fundamental concepts of Javascript and questions asked in javascript interview.","HeaderImage":"/BL-1006/header.png","isPublished":true},"content":"\n## Explain \"hoisting\" {#Explain-hoisting}\n\nHoisting is JavaScript's default behavior of moving all declarations to the top of the current scope.\nNote that the declaration is not actually moved - the JavaScript engine parses the declarations during compilation and becomes aware of declarations and their scopes.\n\n```\nconsole.log(foo); // undefined\nvar foo = 1;\nconsole.log(foo); // 1\n```\n\nFunction declarations have the body hoisted while the function expressions only has the variable declaration hoisted.\n\n```\n// Function Declaration\nconsole.log(foo); // [Function: foo]\nfoo(); // 'FOOOOO'\nfunction foo() {\n  console.log('FOOOOO');\n}\nconsole.log(foo); // [Function: foo]\n\n// Function Expression\nconsole.log(bar); // undefined\nbar(); // Uncaught TypeError: bar is not a function\nvar bar = function () {\n  console.log('BARRRR');\n};\nconsole.log(bar); // [Function: bar]\n```\n\nVariables defined with let and const are hoisted to the top of the block, but not initialized.Meaning that the block of code is aware of the variable, but it cannot be used until it has been declared.\n\n## What is a closure {#What-is-a-closure}\n\nJavaScript implements a scoping mechanism named lexical scoping (or static scoping). Lexical scoping means that the accessibility of variables is determined by the position of the variables inside the nested scopes.\n\nSimpler, the lexical scoping means that inside the inner scope you can access variables of outer scopes.\n\n**Closures are functions that have access to the outer (enclosing) function's variables scope even after the outer function has returned.**\n\n```\nfunction outerFunc() {\n  let outerVar = 'I am outside!';\n  function innerFunc() {\n    console.log(outerVar); // => logs \"I am outside!\"\n  }\n  return innerFunc;\n}\nfunction exec() {\n  const myInnerFunc = outerFunc();\n  myInnerFunc();\n}\nexec();\n```\n\nNow innerFunc() is executed outside of its lexical scope, but exactly in the scope of exec() function. And what's important:\ninnerFunc() still has access to outerVar from its lexical scope, even being executed outside of its lexical scope.\n\n## JavaScript Rest vs Spread Operator {#JavaScript-Rest-vs-Spread-Operator}\n\n### Rest Operator {#Rest-Operator}\n\n**The rest operator (...) is used to put the rest of some specific user-supplied values into a JavaScript array.**\n\nFor instance, consider this code that uses rest to enclose some values into an array:\n\n```\n// Use rest to enclose the rest of specific user-supplied values into an array:\nfunction myBio(firstName, lastName, ...otherInfo) {\n  return otherInfo;\n}\n\n// Invoke myBio function while passing five arguments to its parameters:\nmyBio(\"Oluwatobi\", \"Sofela\", \"CodeSweetly\", \"Web Developer\", \"Male\");\n\n// The invocation above will return:\n[\"CodeSweetly\", \"Web Developer\", \"Male\"]\n```\n\n### Spread Operator {#Spread-Operator}\n\n**The spread operator (...) helps you expand iterables into individual elements.**\nA spread operator is effective only when used within array literals, function calls, or initialized properties objects.\n\n### Example 1: How Spread Works in an Array Literal {#Example-1-How-Spread-Works-in-an-Array-Literal}\n\n```\nconst myName = [\"Sofela\", \"is\", \"my\"];\nconst aboutMe = [\"Oluwatobi\", ...myName, \"name.\"];\n\nconsole.log(aboutMe);\n\n// The invocation above will return:\n[ \"Oluwatobi\", \"Sofela\", \"is\", \"my\", \"name.\" ]\n```\n\nSuppose we did not use the spread syntax to duplicate myName’s content. For instance, if we had written const aboutMe = [\"Oluwatobi\", myName, \"name.\"]. In such a case, the computer would have assigned a reference back to myName\n\n### Example 2: How to Use Spread to Convert a String into Individual Array Items {#Example-2-How-to-Use-Spread-to-Convert-a-String-into-Individual-Array-Items}\n\n```\nconst myName = \"Oluwatobi Sofela\";\n\nconsole.log([...myName]);\n\n// The invocation above will return:\n[ \"O\", \"l\", \"u\", \"w\", \"a\", \"t\", \"o\", \"b\", \"i\", \" \", \"S\", \"o\", \"f\", \"e\", \"l\", \"a\" ]\n```\n\n### Example 3: How the Spread Operator Works in a Function Call {#Example-3-How-the-Spread-Operator-Works-in-a-Function-Call}\n\n```\nconst numbers = [1, 3, 5, 7];\n\nfunction addNumbers(a, b, c, d) {\n  return a + b + c + d;\n}\n\nconsole.log(addNumbers(...numbers));\n\n// The invocation above will return:\n16\n```\n\nSuppose the numbers array had more than four items. In such a case, the computer will only use the first four items as addNumbers() argument and ignore the rest.\n\n```\nconst numbers = [1, 3, 5, 7, 10, 200, 90, 59];\n\nfunction addNumbers(a, b, c, d) {\n  return a + b + c + d;\n}\n\nconsole.log(addNumbers(...numbers));\n\n// The invocation above will return:\n16\n```\n\n### Example 4: How Spread Works in an Object Literal {#Example-4-How-Spread-Works-in-an-Object-Literal}\n\n```\nconst myNames = [\"Oluwatobi\", \"Sofela\"];\nconst bio = { ...myNames, runs: \"codesweetly.com\" };\n\nconsole.log(bio);\n\n// The invocation above will return:\n\n{ 0: \"Oluwatobi\", 1: \"Sofela\", runs: \"codesweetly.com\" }\n```\n\n- Spread operators can’t expand object literal’s values\n- Since a properties object is not an iterable object, you cannot use the spread operator to expand its values.\n- However, you can use the spread operator to clone properties from one object into another.\n\n```\nconst myName = { firstName: \"Oluwatobi\", lastName: \"Sofela\" };\nconst bio = { ...myName, website: \"codesweetly.com\" };\n\nconsole.log(bio);\n\n// The invocation above will return:\n{ firstName: \"Oluwatobi\", lastName: \"Sofela\", website: \"codesweetly.com\" };\n```\n\n## Pure vs Impure Functions in JavaScript {#Pure-vs-Impure-Functions-in-JavaScript}\n\n1. Pure Functions:\n\n- They must be predictable\n- They must have no side effects\n\nIdentical inputs will always return identical outputs, no matter how many times a pure function is called.\n\n2.  Impure Function:\n\n- Unpredictable\n- Has side-effects\n\nSide Effects can be:-\n\n- **Modifying a global variable**\n- **Modifying an argument**\n- **External dependency (APIs, outer variables)**\n- **DOM manipulation**\n- **Reading/writing files**\n\n```\n//IMPURE FUNCTION\nconst impureAddToArray = (arr1, num) => {\n  //altering arr1 in-place by pushing\n  arr1.push(num);\n  return arr1;\n};\n\n// PURE FUNCTION\n// Adding a value to an array via a pure function instead can be achieved using the spread operator, which makes a copy of the original array without mutating it.\n\nconst pureAddToArray = (arr1, num) => {\n  return [...arr1, num];\n};\n```\n\n```\n// IMPURE FUNCTION\nconst impureAddToObj = (obj, key, val) => {\n  obj[key] = val;\n  return obj;\n};\n\nBecause we're modifying the object in-place, the above approach is considered impure. Below is its pure counterpart, utilising the spread operator again.\n\n// PURE FUNCTION\nconst  pureAddToObj = (obj, key, val) => {\n  return { ...obj, [key]: val };\n}\n```\n\n## Higher Order Functions {#Higher-Order-Functions}\n\nA higher order function is a function that takes a function as an argument, or returns a function.\n\n- Some examples of higher order functions are .map() , .filter() and .reduce(). Both of them take a function as an argument.\n\n### Map Method {#Map-Method}\n\nUsing map method in javaScript creates an array by calling a specific function on each element present in the parent array.It returns a new array and elements of arrays are result of callback function.\n\n```\nSyntax:\narr.map(function(element, index, array){  }, this);\nThe this argument will be used inside the callback function. By default, its value is undefined .\n```\n\n```\nExample:\nlet arr = [2, 3, 5, 7]\n\narr.map(function(element, index, array){\n\tconsole.log(this) // 80\n}, 80);\n```\n\n### Filter Method {#Filter-Method}\n\nThe filter() method takes in a callback function and calls that function for every item it iterates over inside the target array. It entails filtering out one or more items (a subset) from a larger collection of items (a superset) based on some condition/preference.\n\n```\nSyntax:\narr.filter(function(element, index, array){  }, this);\nThe this argument will be used inside the callback function. By default, its value is undefined .\n```\n\n- Example: Filter items out of an array\n\n```\nlet people = [\n    {name: \"aaron\",age: 65},\n    {name: \"beth\",age: 2},\n    {name: \"cara\",age: 13},\n    {name: \"daniel\",age: 3},\n    {name: \"ella\",age: 25},\n    {name: \"fin\",age: 1},\n    {name: \"george\",age: 43},\n]\n\nlet toddlers = people.filter(person => person.age <= 3)\n\nconsole.log(toddlers)\n\n/*\n[{\n  age: 2,\n  name: \"beth\"\n}, {\n  age: 3,\n  name: \"daniel\"\n}, {\n  age: 1,\n  name: \"fin\"\n}]\n*/\n```\n\n- Example: How to access the context object with this\n\n```\nlet people = [\n    {name: \"aaron\", age: 65},\n    {name: \"beth\", age: 15},\n    {name: \"cara\", age: 13},\n    {name: \"daniel\", age: 3},\n    {name: \"ella\", age: 25},\n    {name: \"fin\", age: 16},\n    {name: \"george\", age: 18},\n]\n\nlet range = {\n  lower: 13,\n  upper: 16\n}\n\n\nlet teenagers = people.filter(function(person) {\n\treturn person.age >= this.lower && person.age <= this.upper;\n}, range)\n\nconsole.log(teenagers)\n\n/*\n[{\n  age: 15,\n  name: \"beth\"\n}, {\n  age: 13,\n  name: \"cara\"\n}, {\n  age: 16,\n  name: \"fin\"\n}]\n*/\n```\n\n### Reduce Method {#Reduce-Method}\n\n```\nSyntax\narray.reduce(function(total, currentValue, currentIndex, arr), initialValue)\n```\n\nArray.reduce takes two parameters.\n\n- The reducer\n- An initial value (optional)\n\n- The reducer is the function doing all the work. As reduce loops over your list, it feeds two parameters to your reducer.\n\n- An accumulator\n\nAccumulator is the eventual return value\nWhen you're looping through the users, how are you keeping track of their total age? You need some counter variable to hold it. That's the accumulator\n\n- The current value\n\nThe current value is just like when you use array[i] in a regular loop.\n\n- Example:\n\n```\nvar euros = [29.76, 41.85, 46.5];\n\nvar sum = euros.reduce( function(total, amount){\n  return total + amount\n}, 0);\n\nsum // 118.11\n```\n\n## Using call(), apply() and bind() {#Using-call-apply-and-bind}\n\nWe can have objects that have their own properties and methods.\nBut object1 cannot use the methods of object2 and vice versa.\n\n![CAB](/BL-1007/cab.png)\n\nWe can use call(), apply(), and bind() methods to tie a function into an object and call the function as if it belonged to that object.\n\n### Call() Method in JavaScript {#Call-Method-in-JavaScript}\n\nThe call() method invokes a function with a specified context.\n\n```\nvar obj = { firstName: \"a\", lastName:\"b\" };\n\nfunction fullName(){\n  return this.firstName + this.lastName;\n}\n```\n\nuse the call() method to tie the function add() to the object obj:\n\n```\nadd.call(obj, 3);\n```\n\n**Use Call() with Multiple Arguments**\n\n```\nfunction fullName(a, b){\n  return this.firstName + this.lastName + a + b;\n}\n\nconsole.log(add.call(obj, \"x\", \"y\"));\n```\n\n### Apply() Method in JavaScript {#Apply-Method-in-JavaScript}\n\nThe apply() method does the exact same as call(). The difference is that call() accepts an argument list, but apply() accepts an array of arguments.\n\n```\nvar obj = { firstName: \"a\", lastName:\"b\" };\n\nfunction fullName(){\n  return this.firstName + this.lastName;\n}\n\nconsole.log(add.apply(obj, [\"x\", \"y\"]));\n```\n\n### Bind() Method in JavaScript {#Bind-Method-in-JavaScript}\n\ncall() and apply() methods are executed immediately when called (and returned a value).\nBut instead of executing a function immediately, bind() returns a copy of a function that can be executed later on.\n\n```\nvar obj = { num: 2 };\n\nfunction add(a, b){\n  return this.num + a + b;\n}\n\nconst func = add.bind(obj, 3, 5);\nfunc(); // Returns 10\n```\n\n## Async and Defer {#Async-and-Defer}\n\n- Without using async and defer\n  The parsing is paused until the script is fetched, and executed. Once this is done, parsing resumes.\n\n![Async-Defer](/BL-1007/without-defer-async-head.png)\n\n- Page loading a script with async\n  The script is fetched asynchronously, and when it’s ready the HTML parsing is paused to execute the script, then it’s resumed.\n\n![Async](/BL-1007/with-async.png)\n\n- Page loading With defer\n  The script is fetched asynchronously, and it’s executed only after the HTML parsing is done.\n\n![Defer](/BL-1007/with-defer.png)\n\n## Event Throtting and debouncing {#Event-Throtting-and-debouncing}\n\nDebouncing and Throttling techniques enhance the performance of your website, also prevent unnecessary API calls and load on the server.\n\nDebouncing and throttling techniques are used to limit the number of times a function can execute.\n\n### Throttling {#Throttling}\n\nThrottling is a technique in which, no matter how many times the user fires the event, the attached function will be executed only once in a given time interval.\n\n**Example**\n\n```\nlet timer;\n\nconst handleInput = (val, delay) => {\n  if (timer) {\n    return;\n  }\n\n  timer = setTimeout(() => {\n    console.log(val);\n    timer = undefined;\n  }, delay);\n};\n\ndocument.getElementById(\"search-box\").addEventListener(\"keypress\", (e) => {\n  handleInput(e.target.value, 1000);\n});\n```\n\n### Debouncing {#Debouncing}\n\nIn the debouncing technique, no matter how many times the user fires the event, the attached function will be executed only after the specified time once the user stops firing the event.\n\n**Example**\n\n```\nlet timer;\n\nconst handleInput = (val, delay) => {\n  clearTimeout(timer);\n\n  timer = setTimeout(() => {\n    console.log(val);\n  }, delay);\n};\n\ndocument.getElementById(\"search-box\").addEventListener(\"keypress\", (e) => {\n  handleInput(e.target.value, 1000);\n});\n```\n\n## Event Bubbling and Capturing {#Event-Bubbling-and-Capturing}\n\n![eventflow](/BL-1007/eventflow.svg)\n\n### Event Bubbling {#Event-Bubbling}\n\n**When an event happens on an element, it first runs the handlers on it, then on its parent, then all the way up on other ancestors.**\n\n```\nLet’s say we have 3 nested elements FORM > DIV > P with a handler on each of them\n\n<form onclick=\"alert('form')\">FORM\n  <div onclick=\"alert('div')\">DIV\n    <p onclick=\"alert('p')\">P</p>\n  </div>\n</form>\n\nA click on the inner <p> first runs onclick:\n\nOn that <p>.\nThen on the outer <div>.\nThen on the outer <form>.\nAnd so on upwards till the document object.\n```\n\n![event-order-bubbling](/BL-1007/event-order-bubbling.svg)\n\n### Event Capturing {#Event-Capturing}\n\n**In event capturing, an event propagates from the outermost element to the target element.**\n\n![event-order-capture](/BL-1007/capture.svg)\n\n```\nClicking on the p element calls the click event handlers of all parent elements, starting from the outer and propagating inside to the target element p:\nhtml → body → article → div → p.\n```\n\n### Stopping bubbling {#Stopping-bubbling}\n\n```\nevent.stopPropagation()\n```\n\nevent.stopPropagation() stops the move upwards, but on the current element all other handlers will run.\n","readTime":{"text":"11 min read","minutes":10.69,"time":641400,"words":2138}},{"data":{"Id":1008,"Title":"Javascript Event Loop - Explained","Author":"Soumyajit","Tags":"Javascript Interview","Topic":"Javascript","Abstract":"Understanding how javascript works under the hood, how it executes our asynchronous javascript code and event loop","HeaderImage":"/BL-1008/header.png","isPublished":true},"content":"\nBrowser JavaScript execution flow, as well as in Node.js, is based on an event loop. `The event loop concept is very simple. There’s an endless loop, where the JavaScript engine waits for tasks, executes them, and then sleeps, waiting for more tasks.`\n\n`The event loop is the secret behind JavaScript’s asynchronous programming.`\n\n## Event Loop Visualisation/Basic Architecture {#Event-Loop-VisualisationBasic-Architecture}\n\n![Event Loop](/BL-1008/eventloop.png)\n\n### Memory Heap {#Memory-Heap}\n\nThis is where all the memory allocation happens for your variables, that you have defined in your program.\n\n### Call Stack {#Call-Stack}\n\nThis represents the single thread provided for JavaScript code execution. This is where all your javascript code gets pushed and executed one by one as the interpreter reads your program, and gets popped out once the execution is done. It is responsible for keeping track of all the operations in line to be executed. Whenever a function is finished, it is popped from the stack.\n\n### Browser or Web APIs {#Browser-or-Web-APIs}\n\nThey are built into your web browser and are able to expose data from the browser and surrounding computer environment and do useful complex things with it. They are not part of the JavaScript language itself, rather they are built on top of the core JavaScript language, providing you with extra superpowers to use in your JavaScript code.\n\nFor example, the Geolocation API provides some simple JavaScript constructs for retrieving location data so you can say, plot your location on a Google Map. In the background, the browser is actually using some complex lower-level code (e.g. C++) to communicate with the device’s GPS hardware (or whatever is available to determine position data), retrieve position data, and return it to the browser environment to use in your code. But again, this complexity is abstracted away from you by the API.\n\n**Common browser APIs**\n\n- APIs for manipulating documents\n- APIs that fetch data from the server\n- Audio and Video APIs\n- Client-side storage APIs\n\n### Event or Callback Queue {#Event-or-Callback-Queue}\n\nThis is where your asynchronous code gets pushed to, and waits for the execution.\n\n### Event Loop {#Event-Loop}\n\nIt has one simple job `to monitor the call stack and the callback queue.`\nIt keeps running continuously and checks the Main stack, if it has any frames to execute, if not then it checks Callback queue, if Callback queue has codes to execute then it pops the message from it to the Main Stack for the execution.\n\n### Job Queue or Microtask Queue {#Job-Queue-or-Microtask-Queue}\n\nApart from Callback Queue, browsers have introduced one more queue which is “Job Queue”, reserved only for new Promise() functionality. So when you use promises in your code, you add .then() method, which is a callback method. These `thenable` methods are added to Job Queue once the promise has returned/resolved, and then gets executed.\n\n## Execution of async function in javascript {#Execution-of-async-function-in-javascript}\n\nWhenever an async function is called, it is sent to a browser API. These are APIs built into the browser.\n\n`An example of this is the setTimeout method. When a setTimeout operation is processed, it is sent to the corresponding API which waits till the specified time to send this operation back in for processing.`\n\n`This operation is then send to the callback queue. Hence, we have a cyclic system for running async operations in JavaScript. The language itself is single-threaded, but the browser APIs act as separate threads.`\n\nThe `event loop` facilitates this process. It has one simple job `to monitor the call stack and the callback queue.` If the call stack is empty, the event loop will take the first event from the queue and will push it to the call stack, which effectively runs. If it is not, then the current function call is processed.\n\n```\nconst foo = () => console.log(\"First\");\nconst bar = () => setTimeout(() => console.log(\"Second\"), 500);\nconst baz = () => console.log(\"Third\");\n\nbar();\nfoo();\nbaz();\n\nOutput:\nFirst\nThird\nSecond\n```\n\n![Callback Queue](/BL-1008/callbackqueue.gif)\n\n## Why Job Queue or Microtask Queue {#Why-Job-Queue-or-Microtask-Queue}\n\nMicro-tasks has high priority in executing callbacks, if event loop tick comes to Micro-tasks, it will execute all the jobs in job queue first until it gets empty, then will move to callback queue.\n\n- The primary reason for prioritizing the micro-task queue is to improve the user experience.\n- Micro-tasks include mutation observer callbacks as well as promise callbacks.\n\n![micro-task Queue](/BL-1008/microtask.gif)\n\nExample:\n\n```\nconsole.log('Message no. 1: Sync');\n\nsetTimeout(function() {\n   console.log('Message no. 2: setTimeout');\n}, 0);\n\nvar promise = new Promise(function(resolve, reject) {\n   resolve();\n});\n\npromise.then(function(resolve) {\n   console.log('Message no. 3: 1st Promise');\n})\n.then(function(resolve) {\n   console.log('Message no. 4: 2nd Promise');\n});\n\nconsole.log('Message no. 5: Sync');\n\n// Message no. 1: Sync\n// Message no. 5: Sync\n// Message no. 3: 1st Promise\n// Message no. 4: 2nd Promise\n// Message no. 2: setTimeout\n```\n\nAll `thenable` callbacks of the promise are called first, then the setTimeout callback is called.\n\n**References:**\n\n- <a href=\"https://towardsdev.com/event-loop-in-javascript-672c07618dc9\" target=\"_blank\">Event Loop</a>\n","readTime":{"text":"5 min read","minutes":4.07,"time":244200,"words":814}},{"data":{"Id":1009,"Title":"Prototype and Prototypical Inheritance","Author":"Soumyajit","Tags":"Javascript Interview","Topic":"Javascript","Abstract":"Understanding And Using Prototype and Prototypical Inheritance in JavaScript","HeaderImage":"/BL-1009/header.jpg","isPublished":true},"content":"\n## Prototype {#Prototype}\n\n![Prototype](/BL-1009/object-prototype-empty.svg)\n\n**The prototype is an object that is associated with every functions and objects by default in JavaScript.**\n\nWhenever we create a function , object or array javacript by default attaches a prototype object to it which contains some additional methods inside it.\n\n![Prototype](/BL-1009/proto.png)\nAll JavaScript objects inherit properties and methods from a prototype:\n\n- Date objects inherit from Date.prototype.\n- Array objects inherit from Array.prototype.\n- Player objects inherit from Player.prototype.\n\n- The Object.prototype is on top of the prototype inheritance chain. Date objects, Array objects, and Player objects all inherit from Object.prototype.\n\n## The Prototype Chain {#The-Prototype-Chain}\n\nPrototypal inheritance uses the concept of prototype chaining.\n\nEvery object created contains [[Prototype]], which points either to another object or null.\n\nExample:-\nAn object C with a [[Prototype]] property that points to object B. Object B’s [[Prototype]] property points to prototype object A. This continues onward, forming a kind of chain called the prototype chain.\n\n## Prototypal Inheritance {#Prototypal-Inheritance}\n\n```\nlet animal = {\n  eats: true\n   walk() {\n    console.log(\"Animal walk\");\n  }\n};\n\nlet rabbit = {\n  jumps: true\n  __proto__ = animal;\n};\n\n\n// we can find both properties in rabbit now:\nconsole.log(rabbit.eats ); // true\n\nrabbit.walk(); // Animal walk\n\n```\n\n![Prototype](/BL-1009/rabbit-animal-object.svg)\n\n```\nconst obj = {\n  firstName: \"sds\",\n  lastName: \"bh\",\n  getFullName: function () {\n    return this.firstName + \" \" + this.lastName;\n  }\n};\n\nconst obj2 = {\n  firstName: \"ab\",\n  __proto__: obj\n};\n\nconsole.log(obj2.getFullName()); //ab bh\n```\n\n## Creating own prototype {#Creating-own-prototype}\n\nCreating Ployfill for bind method\n\n```\nconst obj = {\n  firstName: \"sds\",\n  lastName: \"bh\"\n};\n\nfunction getFullName(state) {\n  return this.firstName + \" \" + this.lastName + \" \" + state;\n}\n\nconst fName = getFullName.bind(obj, \"rnc\");\nconsole.log(fName()); //sds bh rnc\n\nFunction.prototype.myBind = function (...args) {\n  const func = this;\n  const params = args.slice(1);\n  return function () {\n    return func.apply(args[0], params);\n  };\n};\n\nconst fName2 = getFullName.myBind(obj, \"bsh\");\nconsole.log(fName2()); //sds bh bsh\n```\n\n## Creating Ployfill for Call, Apply and Bind method {#Creating-Ployfill-for-Call-Apply-and-Bind-method}\n\n```\nconst obj = {\n  firstName: \"sds\",\n  lastName: \"bh\"\n};\n\nfunction getFullName(state) {\n  return this.firstName + \" \" + this.lastName + \" \" + state;\n}\n\nFunction.prototype.myBind = function (obj, ...args) {\n  obj.func = this;\n  return () => {\n    return obj.func(...args);\n  };\n};\n\nFunction.prototype.myCall = function (obj, ...args) {\n  obj.func = this;\n  return obj.func(...args);\n};\n\nFunction.prototype.myApply = function (obj, args) {\n  obj.func = this;\n  return obj.func(...args);\n};\n\nconst fName2 = getFullName.myBind(obj, \"bsh\");\nconsole.log(fName2()); //sds bh bsh\n\nconsole.log(getFullName.myCall(obj, \"kkr\"));  //sds bh kkr\n\nconsole.log(getFullName.myApply(obj, [\"kkr\"]));  //sds bh kkr\n```\n","readTime":{"text":"3 min read","minutes":2.06,"time":123600,"words":412}}],"topics":["Git","React","Javascript"],"topicName":"Javascript"},"__N_SSG":true}