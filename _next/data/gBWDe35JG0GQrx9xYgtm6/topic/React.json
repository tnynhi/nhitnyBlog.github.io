{"pageProps":{"blogs":[{"data":{"Id":1002,"Title":"Client Vs Server Side Rendering","Author":"Soumyajit","Tags":"React Next","Topic":"React","Abstract":"Difference between different types of rendering techniques and advantage of Next.js over React.js.","HeaderImage":"/BL-1002/next-react.jpg","isPublished":true},"content":"\n## Client Side Rendering {#Client-Side-Rendering}\n\n![Client Side Rendering](/BL-1002/csr.png)\n\nWhen we talk about client-side rendering,it’s about rendering content in the browser using JavaScript.\n\nSo instead of getting all the content from the HTML document itself, a simple HTML document with a JavaScript file in initial loading itself is received, which renders the rest of the site using the browser.\n\nWith client-side rendering, the initial page load is naturally a bit slow. However, after that, every subsequent page load is very fast. In this approach, communication with server happens only for getting the run-time data. Moreover, there is no need to reload the entire UI after every call to the server. The client-side framework manages to update UI with changed data by re-rendering only that particular DOM element.\n\n## Server Side Rendering {#Server-Side-Rendering}\n\n![Server Side Rendering](/BL-1002/ssr.png)\n\nIn server-side rendering when a user makes a request to a webpage, the server prepares an HTML page by fetching user-specific data and sends it to the user’s machine over the internet. Webpages are generated on your server for every request. This entire process of fetching data from the database, creating an HTML page and serve it to user is known as SSR.\n\n## Static Site Generation {#Static-Site-Generation}\n\nAt build time, your app will fetch all the data required and compile it down to static webpages. After a production build is created, every request is going to reuse that statically generated HTML file. This provides the best performance and can easily be cached on a CDN.\n\n## Problems with React.js {#Problems-with-React.js}\n\nReact uses Client Side Rendering. With React, nothing gets displayed until all of your JavaScript loads. Your HTML is nearly empty and React injects your content in your HTML with JavaScript.\nThis leads multiple problems:-\n\n- When the browser is loading the JavaScript, the screen is blank because `<div id=\"root\"></div>` does not show anything. Depending on the size of your JavaScript bundle, this could lead to your visitors staring at a white screen for a couple of seconds.\n\n- Most SEO crawlers do not have JavaScript enabled. DuckDuckGo, Google, Bing and any other search engine would not actually know what is on your website since it requires JavaScript to display the content. You will not be ranked at all on Search Engines.\n\n## Methods for Prerendering using Next.js {#Methods-for-Prerendering-using-Next.js}\n\nNext.js offers `(Server Side Rendering)SSR` and `(Static Site Generation)SSG` using `getStaticProps` and `getServerSideProps`.\n\n### getStaticProps {#getStaticProps}\n\ngetStaticProps is a server-side function that will only be called at build time. The build will then use the response from getStaticProps to generate a static webpage.\n\nSince stale data is a problem with static generated pages, there is an option you can set to revalidate your static page and rebuild it if data changes. revalidate: 60 will check your data every 60 seconds and rebuild the page if needed.\n\nExample Use:\n\n```\n// This function gets called at build time on server-side.\nexport async function getStaticProps() {\nconst res = await fetch('https://.../data');\nconst data = await res.json();\n\n// By returning { props: data }, the Dashboard component\n// will receive `data` as a prop at build time\nreturn {\nprops: {\ndata\n},\n// Check if data changes every 60 seconds.\n// Rebuild page if different\nrevalidate: 60\n};\n}\n\n// data will be populated at build time by getStaticProps()\nexport default function Dashboard({ data }) {\nreturn <div>{data}</div>;\n}\n```\n\n### getServerSideProps {#getServerSideProps}\n\ngetServerSideProps is similar to getStaticProps but is called every time the page loads instead of at build time. This ensures that all of your initial data is up to date on every load.\n\nSince this is called on every load, you do not need to revalidate like getStaticProps. This also leads to a slower load time since you are no longer serving a static file, but have to rebuild on every load.\n\nExample Use:\n\n```\n// This function gets called at build time on server-side.\nexport async function getServerSideProps() {\nconst res = await fetch('https://.../data');\nconst data = await res.json();\n\n// By returning { props: data }, the Dashboard component\n// will receive `data` as a prop at build time\nreturn {\nprops: {\ndata\n}\n};\n}\n\n// data will be populated at build time by getServerSideProps()\nexport default function Dashboard({ data }) {\nreturn <div>{data}</div>;\n}\n```\n\n## Benefits of using Next.js {#Benefits-of-using-Next.js}\n\n- Search engines can crawl the site for better SEO.\n- The initial page load is faster.\n  ![nextjs pros and cons](/BL-1002/nextjs-pros-and-cons.png)\n\n**References:**\n\n- <a href=\"https://nextjs.org/docs/getting-started\" target=\"_blank\">Next.js</a>\n","readTime":{"text":"4 min read","minutes":3.73,"time":223800,"words":746}},{"data":{"Id":1003,"Title":"Core Concept You Need to Know About React","Author":"Soumyajit","Tags":"React Interview","Topic":"React","Abstract":"Learning some of the fundamental concepts of React.js and top questions asked in react interview.","HeaderImage":"/BL-1003/reactjs.png","isPublished":true},"content":"\n## Why use react.js {#Why-use-react.js}\n\n**_1.Reusable Components:_**\n\nReact provides a component based structure.Each tiny elements like button, checkbox, dropdown etc can be a component and the we create wrapper components composed of those smaller components.Each component decides how it should be rendered. Each component has its own internal logic.\n\n**_2.Fast render with Virtual DOM_**\n\nReact uses virtual DOM to render the view.virtual DOM is a virtual representation of the real DOM. Each time the data changes in a react app, a new virtual DOM gets created. Creating a virtual DOM is much faster than rendering the UI inside the browser. Therefore, with the use of virtual DOM, the efficiency of the app improves.\n\n**_3.SEO friendly_**\n\nReact allows developers to develop user interfaces that can be easily navigated in various search engines. It also allows server-side rendering, which boosts the SEO of an app.\n\n## What is JSX? {#What-is-JSX}\n\nJSX stands for JavaScript XML.\nIt allows us to write HTML inside JavaScript and place them in the DOM without using functions like `appendChild( )` or `createElement( )`.\n\n- Without using JSX, we would have to create an element by the following process:\n\n```\nconst text = React.createElement('p', {}, 'This is a text');\nconst container = React.createElement('div','{}',text );\nReactDOM.render(container,document.getElementById('app'));\n```\n\n- Using JSX, the above code can be simplified:\n\n````\nconst container = (\n\n <div>\n   <p>This is a text</p>\n </div>\n);\nReactDOM.render(container,document.getElementById('app'));```\n````\n\nAs one can see in the code above, we are directly using HTML inside JavaScript\\*\n\n## What is the virtual DOM? How does react use the virtual DOM to render the UI? {#What-is-the-virtual-DOM-How-does-react-use-the-virtual-DOM-to-render-the-UI}\n\n_DOM stands for 'Document Object Model'. In simple terms, it is a structured representation of the HTML elements that are present in a webpage or web-app. DOM represents the entire UI of your application_\n\nVirtual DOM is a concept where a virtual representation of the real DOM is kept inside the memory and is synced with the real DOM by a library such as ReactDOM.\n\n![Virtual Dom](/BL-1003/vdom.png)\n\n**Why was virtual DOM introduced?**\n\nDOM manipulation is an integral part of any web application, but DOM manipulation is quite slow when compared to other operations in JavaScript.\n\nThe efficiency of the application gets affected when several DOM manipulations are being done. Most JavaScript frameworks update the entire DOM even when a small part of the DOM changes.\n\nFor example, consider a list that is being rendered inside the DOM. If one of the items in the list changes, the entire list gets rendered again instead of just rendering the item that was changed/updated. This is called inefficient updating.\nTo address the problem of inefficient updating, the react team introduced the concept of virtual DOM.\n\n**How does it work?**\n\n![Virtual Dom](/BL-1003/real-virtual.png)\n\nFor every DOM object, there is a corresponding virtual DOM object(copy), which has the same properties.\n\nThe main difference between the real DOM object and the virtual DOM object is that any changes in the virtual DOM object will not reflect on the screen directly. Consider a virtual DOM object as a blueprint of the real DOM object.\nWhenever a JSX element gets rendered, every virtual DOM object gets updated.\n\nReact uses two virtual DOMs to render the user interface. One of them is used to store the current state of the objects and the other to store the previous state of the objects.\n\nWhenever the virtual DOM gets updated, react compares the two virtual DOMs and gets to know about which virtual DOM objects were updated.\n\nAfter knowing which objects were updated, react renders only those objects inside the real DOM instead of rendering the complete real DOM.This way, with the use of virtual DOM, react solves the problem of inefficient updating\n\n## Explain React state and props? {#Explain-React-state-and-props}\n\nA React component can access dynamic information in two ways: props and state.\n\n### React State {#React-State}\n\nEvery component in react has a built-in state object, which contains all the property values that belong to that component.\n\nIn other words, the state object controls the behaviour of a component. Any change in the property values of the state object leads to re-rendering of the component.\n\n_Note- State object is not available in functional components but, we can use React Hooks to add state to a functional component._\n\nHow to declare a state object?\n\n```\nExample:\nclass Car extends React.Component{\n constructor(props){\n   super(props);\n   this.state = {\n     brand: \"BMW\",\n     color: \"black\"\n   }\n }\n}\n```\n\nHow to use and update the state object?\n\n```\nclass Car extends React.Component {\n constructor(props) {\n   super(props);\n   this.state = {\n     brand: \"BMW\",\n     color: \"Black\"\n   };\n }\n\n changeColor() {\n   this.setState(prevState => {\n     return { color: \"Red\" };\n   });\n }\n\n render() {\n   return (\n     <div>\n       <button onClick={() => this.changeColor()}>Change Color</button>\n       <p>{this.state.color}</p>\n     </div>\n   );\n }\n}\n\n```\n\nAs one can see in the code above, we can use the state by calling this.state.propertyName and we can change the state object property using setState method.\n\n### React Props {#React-Props}\n\nEvery react component, accepts a single object argument called props (which stands for “properties”).\n\nThese props can be passed to a component using HTML attributes.\n\nUsing props, we can pass data from one component to another.\n\n- While rendering a component, we can pass the props as a HTML attribute:\n\n```\n<Car brand=\"Mercedes\"/>\n```\n\nThe component receives the props:\n\n- In Class component:\n\n```\nclass Car extends React.Component {\n constructor(props) {\n   super(props);\n   this.state = {\n     brand: this.props.brand,\n     color: \"Black\"\n   };\n }\n}\n```\n\n- In Functional component:\n\n```\nfunction Car(props) {\n  render() {\n      return <h1>Name is {props.name}!</h1>;\n   }\n}\n```\n\n**Note- Props are read-only. They cannot be manipulated or changed inside a component**\n\n## Explain React Hooks? {#Explain-React-Hooks}\n\nHooks are functions that let us “hook into” React state and lifecycle features from a `functional component.`\nReact Hooks cannot be used in class components.\n\nWhy were Hooks introduced in React?\nReact hooks were introduced in the 16.8 version of React.\nPreviously, functional components were called stateless components. Only class components were used for state management and lifecycle methods.\n\nThe need to change a functional component to a class component, whenever state management or lifecycle methods were to be used, led to the development of Hooks.\n\n**Example of a hook:**\n\n`useState hook:`\nIn functional components, useState hook lets us define state for a component:\n\n```\nfunction Person(props) {\n // We are declaring a state variable called name.\n // setName is a function to update/change the value of name\n let [name, setName] = useState('');\n}\n```\n\n## What are the different lifecycle methods in React? {#What-are-the-different-lifecycle-methods-in-React}\n\nEach component in react goes through three phases: `Mounting`, `Updating`, and `Unmounting`.\n\n- **Mounting** :- Birth of your component\n- **Update** :- Growth of your component\n- **Unmount** :- Death of your component\n\n![React Life Cycle Methods](/BL-1003/ReactLifeCycle.png)\n\n### Common React Lifecycle Methods {#Common-React-Lifecycle-Methods}\n\n- **constructor()**\n\nThis is used only if you have a class-based Component and it serves the purpose of initializing the state of a Component. In case of functional Components, the useState() hook is used to do the same.\n\n- **render()**\n\nThis is the method that is `responsible for inserting a Component into the DOM`.\n\nThe render() method is the most used lifecycle method. This is because render() is the only required method within a class component in React.\n\nIt happens during the `mounting` and `updating` of your component.\n\n```\nBelow is an example of a simple render() in React.\n\nclass Hello extends Component{\n   render(){\n      return <div>Hello {this.props.name}</div>\n   }\n}\n\n```\n\n**A render() can also return a null if there is nothing to render for that component.**\n\n- **componentDidMount()**\n\nThis is invoked `after a Component is inserted into the DOM for the first time`.\n\nWhen component has been mounted and ready, that’s when the next React lifecycle method componentDidMount() comes in play.\n\ncomponentDidMount() is called as soon as the component is mounted and ready. This is a good place to initiate API calls, if you need to load data from a remote endpoint.\n\n`componentDidMount() allows the use of setState()`.\n\n- **componentDidUpdate()**\n\nThis is the method invoked after `re-rendering an updated Component`. This method can give you the information about a Component’s previous state and previous props. This lifecycle method is invoked as soon as the updating happens. The most common use case for the componentDidUpdate() method is updating the DOM in response to prop or state changes.\n\nYou can call setState() in this lifecycle, but keep in mind that you will need to wrap it in a condition to check for state or prop changes from previous state. Incorrect usage of setState() can lead to an infinite loop.\n\n```\nTake a look at the example below that shows a typical usage example of this lifecycle method.\n\ncomponentDidUpdate(prevProps) {\n//Typical usage, don't forget to compare the props\nif (this.props.userName !== prevProps.userName) {\nthis.fetchData(this.props.userName);\n}\n}\n\n```\n\nNotice in the above example that we are comparing the current props to the previous props. This is to check if there has been a change in props from what it currently is. In this case, there won’t be a need to make the API call if the props did not change.\n\n- **componentWillUnmount()**\n\nAs the name suggests this lifecycle method is called just `before the component is unmounted and destroyed`.\n\nYou cannot modify the component state in componentWillUnmount lifecycle.\n\nThis is where you can perform any cleanups that need to be done such as invalidating timers, canceling network requests, removing event listeners, and so on.\n\n```\ncomponentWillUnmount() {\nwindow.removeEventListener('resize', this.resizeListener)\n}\n```\n\n## What are keys in React? {#What-are-keys-in-React}\n\nA key is a special string attribute that needs to be included when using lists of elements.\n\nExample of a list using key:\n\n```\nconst ids = [1,2,3,4,5];\nconst listElements = ids.map((id)=>{\nreturn(\n <li key={id.toString()}>\n   {id}\n </li>\n )\n})\n```\n\n**Importance of keys:-**\n\n- Keys help react identify which elements were added, changed or removed.\n- Keys should be given to array elements for providing a unique identity for each element.\n- Without keys, React does not understand the order or uniqueness of each element.\n- With keys, React has an idea of which particular element was deleted,edited, and added.\n\n## React pure component {#React-pure-component}\n\nA React component is considered pure if it renders the same output for the same state and props. For class components like this, React provides the PureComponent base class. Class components that extend the `React.PureComponent` class are treated as `pure components`.\n\nPure components have some performance improvements and render optimizations since React implements the shouldComponentUpdate() method for them with a shallow comparison for props and state.\n\n**Features of React Pure Components**\n\n- Prevents re-rendering of Component if props or state is the same\n- Takes care of “shouldComponentUpdate” implicitly\n- State and Props are Shallow Compared\n- Pure Components are more performant in certain cases\n\n**React Components re-renders in the following scenarios:**\n\n- “setState” is called in Component\n- “props” values are updated\n- this.forceUpdate() is called\n\n`In the case of Pure Components, the React components do not re-render blindly without considering the updated values of React “props” and “state”. If updated values are the same as previous values, render is not triggered.`\n","readTime":{"text":"10 min read","minutes":9.235,"time":554100,"words":1847}},{"data":{"Id":1010,"Title":"React Lifecycle Methods","Author":"Soumyajit","Tags":"React Interview","Topic":"React","Abstract":"Lifecycle methods are series of events that happen throughout the birth, growth, and death of a React component.","HeaderImage":"/BL-1010/Header.jpg","isPublished":true},"content":"\n**Visual overview of topics covered in this tutorial**\n\n![Lifecycle](/BL-1010/Lifecycle.png)\n\n## What is the React component lifecycle? {#What-is-the-React-component-lifecycle}\n\nIn React, components go through a lifecycle of events:\n\n- Mounting (adding nodes to the DOM)\n- Updating (altering existing nodes in the DOM)\n- Unmounting (removing nodes from the DOM)\n\n## Mounting lifecycle methods {#Mounting-lifecycle-methods}\n\nThe mounting phase refers to the phase during which a component is created and inserted to the DOM.\nThe following methods are called in order.\n\n- constructor()\n- static getDerivedStateFromProps()\n- render()\n- componentDidMount()\n\n### constructor() {#constructor}\n\nThe constructor() is the very first method that is invoked before the component is mounted to the DOM.\n\nThe constructor method is called before the component is mounted to the DOM. In most cases, you would initialize state and bind event handlers methods within the constructor method.\n\nExample of the constructor() React lifecycle method in action:\n\n```\nconst MyComponent extends React.Component {\n  constructor(props) {\n   super(props)\n    this.state = {\n       points: 0\n    }\n    this.handlePoints = this.handlePoints.bind(this)\n    }\n}\n```\n\n### static getDerivedStateFromProps() {#static-getDerivedStateFromProps}\n\nIts main function is to ensure that the state and props are in sync for when it’s required.\n\nThe basic structure of the static getDerivedStateFromProps() looks like this:\n\n```\nstatic getDerivedStateFromProps(props, state) {\n  //do stuff here\n}\n```\n\n```\nYou can return an object to update the state of the component:\n\nstatic getDerivedStateFromProps(props, state) {\n    return {\n       points: 200 // update state with this\n    }\n}\n\nOr you can return null to make no updates:\n\nstatic getDerivedStateFromProps(props, state) {\n return null\n}\n```\n\n```\nclass App extends Component {\n  state = {\n    points: 10\n  }\n\n  // *******\n  //  NB: Not the recommended way to use this method. Just an example. Unconditionally overriding state here is generally considered a bad idea\n  // ********\n\n  static getDerivedStateFromProps(props, state) {\n    return {\n      points: 1000\n    }\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <p>\n            You've scored {this.state.points} points.\n          </p>\n        </header>\n      </div>\n    );\n  }\n}\n\nThe 1000 comes from updating state within the static getDerivedStateFromProps method.\n\n```\n\n### render() {#render}\n\nAs the name suggests it handles the rendering of your component to the UI\n\n```\nclass Hello extends Component{\n   render(){\n      return <div>Hello {this.props.name}</div>\n   }\n}\n```\n\nThe render() method returns JSX that is displayed in the UI. A render() can also return a null if there is nothing to render for that component.\n\nA render() method has to be pure with no side-effects.\nReact requires that your render() is pure. Pure functions are those that do not have any side-effects and will always return the same output when the same inputs are passed. This means that you can not `setState() within a render()`. `You cannot modify the component state within the render().`\n\n### componentDidMount {#componentDidMount}\n\nAfter render is called, `the component is mounted to the DOM and the componentDidMount method is invoked.`\n\nThis function is invoked immediately after the component is mounted to the DOM.\n\nYou would use the componentDidMount lifecycle method to grab a DOM node from the component tree immediately after it’s mounted.\n\n**If you also want to make network requests as soon as the component is mounted to the DOM, this is a perfect place to do so.**\n\n```\ncomponentDidMount() {\n  this.fetchListOfTweets() // where fetchListOfTweets initiates a netowrk request to fetch a certain list of tweets.\n}\n```\n\n**You could also set up subscriptions such as timers**\n\n```\n// e.g requestAnimationFrame\ncomponentDidMount() {\n    window.requestAnimationFrame(this._updateCountdown);\n }\n```\n\n## Updating lifecycle methods {#Updating-lifecycle-methods}\n\nWhenever a change is made to the state or props of a React component, the component is rerendered. In simple terms, the component is updated. This is the updating phase of the React component lifecycle.\n\n- shouldComponentUpdate()\n- render()\n- getSnapshotBeforeUpdate()\n- componentDidUpdate()\n\n### shouldComponentUpdate() {#shouldComponentUpdate}\n\nIn most cases, you’ll want a component to rerender when state or props changes. However, you do have control over this behavior.\n\nWithin this lifecycle method, you can return a boolean true or false and control whether the component gets rerendered (e.g., upon a change in state or props).\n\n```\nshouldComponentUpdate(nextProps, nextState)\n{\n return this.props.title !== nextProps.title ||\n  this.state.input !== nextState.input\n}\n```\n\n### render() {#render}\n\nAfter the shouldComponentUpdate method is called, render is called immediately afterward, depending on the returned value from shouldComponentUpdate, which defaults to true.\n\n### getSnapshotBeforeUpdate() {#getSnapshotBeforeUpdate}\n\nThe getSnapshotBeforeUpdatelifecycle method stores the previous values of the state after the DOM is updated. getSnapshotBeforeUpdate() is called right after the render method.\n\n```\ngetSnapshotBeforeUpdate(prevProps, prevState) {\n\n}\n```\n\nHere’s the important thing: the value queried from the DOM in getSnapshotBeforeUpdate refers to the `value just before the DOM is updated, even though the render method was previously called`.\n\n`The getSnapshotBeforeUpdate React lifecycle method doesn’t work on its own. It is meant to be used in conjunction with the componentDidUpdate lifecycle method`.\n\n### componentDidUpdate() {#componentDidUpdate}\n\nThe componentDidUpdate lifecycle method is invoked after the getSnapshotBeforeUpdate. As with the getSnapshotBeforeUpdate method it receives the previous props and state as arguments:\n\n```\ncomponentDidUpdate(prevProps, prevState) {\n\n}\n```\n\nHowever it also takes whatever value is returned from the getSnapshotBeforeUpdate lifecycle method is passed as the third argument to the componentDidUpdate method.\n\n```\ncomponentDidUpdate(prevProps, prevState, snapshot) {\n\n}\n```\n\n## Unmounting lifecycle method {#Unmounting-lifecycle-method}\n\nThe following method is invoked during the component unmounting phase\n\n- componentWillUnmount()\n\n### componentWillUnmount() {#componentWillUnmount}\n\nThe componentWillUnmount lifecycle method is invoked immediately before a component is unmounted and destroyed. This is the ideal place to perform any necessary cleanup such as clearing up timers, cancelling network requests, or cleaning up any subscriptions that were created in componentDidMount().\n\n```\n// e.g add event listener\ncomponentDidMount() {\n  el.addEventListener()\n}\n```\n\n```\n// e.g remove event listener\ncomponentWillUnmount() {\n  el.removeEventListener()\n}\n```\n\n**References:**\n\n- <a href=\"https://programmingwithmosh.com/javascript/react-lifecycle-methods\" target=\"_blank\">React Lifecycle Methods- A Deep Dive</a>\n- <a href=\"https://blog.logrocket.com/react-lifecycle-methods-tutorial-examples\" target=\"_blank\">React lifecycle methods: An approachable tutorial with examples</a>\n","readTime":{"text":"5 min read","minutes":4.81,"time":288600,"words":962}}],"topics":["Git","React","Javascript"],"topicName":"React"},"__N_SSG":true}